document_begin:
file_begin: file: "miles_span.w"
limbo_begin: loc.begin: 1 1, loc.end: 3 1
include_file: file: "boilerplate.w", quoted: false, trailingText: " %<< legal stuff: PLEASE READ IT BEFORE MAKING ANY CHANGES!", loc.begin: 1 1, loc.end: 3 1
file_begin: file: "boilerplate.w"
limbo_begin: loc.begin: 1 1, loc.end: 39 1
free_text: type: "tex", loc.begin: 1 1, loc.end: 39 1, text: "% This material goes at the beginning of all Stanford GraphBase CWEB files

\def\topofcontents{
  \leftline{\sc\today\ at \hours}\bigskip\bigskip
  \centerline{\titlefont\title}}

\font\ninett=cmtt9
\def\botofcontents{\vskip 0pt plus 1filll
    \ninerm\baselineskip10pt
    \noindent\copyright\ 1993 Stanford University
    \bigskip\noindent
    This file may be freely copied and distributed, provided that
    no changes whatsoever are made. All users are asked to help keep
    the Stanford GraphBase files consistent and ``uncorrupted,''
    identical everywhere in the world. Changes are permissible only
    if the modified file is given a new name, different from the names of
    existing files in the Stanford GraphBase, and only if the modified file is
    clearly identified as not being part of that GraphBase.
    (The {\ninett CWEB} system has a ``change file'' facility by
    which users can easily make minor alterations without modifying
    the master source files in any way. Everybody is supposed to use
    change files instead of changing the files.)
    The author has tried his best to produce correct and useful programs,
    in order to help promote computer science research,
    but no warranty of any kind should be assumed.
    \smallskip\noindent
    Preliminary work on the Stanford GraphBase project
    was supported in part by National Science
    Foundation grant CCR-86-10181.}

\def\prerequisite#1{\def\startsection{\noindent
    Important: Before reading {\sc\title},
    please read or at least skim the program for {\sc#1}.\bigskip
    \let\startsection=\stsec\stsec}}
\def\prerequisites#1#2{\def\startsection{\noindent
    Important: Before reading {\sc\title}, please read
    or at least skim the programs for {\sc#1} and {\sc#2}.\bigskip
    \let\startsection=\stsec\stsec}}
"
limbo_end: loc.begin: 1 1, loc.end: 39 1
file_end: file: "boilerplate.w"
include_file: file: "gb_types.w", quoted: false, trailingText: "", loc.begin: 3 1, loc.end: 4 1
file_begin: file: "gb_types.w"
limbo_begin: loc.begin: 1 1, loc.end: 1 79
cweb_comment: comment: " This file makes CWEAVE treat Graph, Arc, Vertex, etc. as reserved words. ", loc.begin: 1 1, loc.end: 1 79
suppresed_format_def: left: "Graph", right: "int", loc.begin: 1 79, loc.end: 3 3
suppresed_format_def: left: "Arc", right: "int", loc.begin: 3 3, loc.end: 4 3
suppresed_format_def: left: "Vertex", right: "int", loc.begin: 4 3, loc.end: 5 3
suppresed_format_def: left: "Area", right: "int", loc.begin: 5 3, loc.end: 6 3
suppresed_format_def: left: "util", right: "int", loc.begin: 6 3, loc.end: 7 3
suppresed_format_def: left: "siz_t", right: "int", loc.begin: 7 3, loc.end: 8 3
free_text: type: "tex", loc.begin: 8 3, loc.end: 9 1, text: "
"
limbo_end: loc.begin: 8 3, loc.end: 9 1
file_end: file: "gb_types.w"
free_text: type: "tex", loc.begin: 4 1, loc.end: 9 27, text: "
\def\title{MILES\_\,SPAN}
\def\<#1>{$\langle${\rm#1}$\rangle$}

\prerequisite{GB\_\,MILES}
@*"
limbo_end: loc.begin: 4 1, loc.end: 9 27
tex_begin: loc.begin: 4 1, loc.end: 9 27
tex_section_begin: type: "starred", title: " Minimum spanning trees.", loc.begin: 4 1, loc.end: 9 27
index_entry: entry: "Graham, Ronald Lewis", loc.begin: 9 27, loc.end: 11 25
index_entry: entry: "Hell, Pavol", loc.begin: 11 25, loc.end: 12 16
index_entry: entry: "Kruskal, Joseph Bernard", loc.begin: 12 16, loc.end: 19 28
index_entry: entry: "Jarn{\'\i}k, Vojt\u ech", loc.begin: 19 28, loc.end: 23 28
index_entry: entry: "Bor{\accent23u}vka, Otakar", loc.begin: 23 28, loc.end: 28 31
free_text: type: "tex", loc.begin: 28 31, loc.end: 52 3, text: "

The present program contains simple implementations of all three
approaches, in an attempt to make practical comparisons of how
they behave on ``realistic'' data. One of the main goals of this
program is to demonstrate a simple way to make machine-independent
comparisons of programs written in \CEE/, by counting memory
references or ``mems.'' In other words, this program is intended
to be read, not just performed.

The author believes that mem counting sheds considerable light on
the problem of determining the relative efficiency of competing
algorithms for practical problems. He hopes other researchers will
enjoy rising to the challenge of devising algorithms that find minimum
spanning trees in significantly fewer mem units than the algorithms
presented here, on problems of the size considered here.

Indeed, mem counting promises to be significant for combinatorial
algorithms of all kinds. The standard graphs available in the
Stanford GraphBase should make it possible to carry out a large
number of machine-independent experiments concerning the practical
efficiency of algorithms that have previously been studied
only asymptotically.

@ "
tex_section_end: loc.begin: 28 31, loc.end: 52 3
tex_end: loc.begin: 28 31, loc.end: 52 3
tex_begin: loc.begin: 28 31, loc.end: 52 3
tex_section_begin: type: "unstarred", loc.begin: 28 31, loc.end: 52 3
free_text: type: "tex", loc.begin: 52 3, loc.end: 52 53, text: "The graphs we will deal with are produced by the "
inner_c_begin: loc.begin: 52 3, loc.end: 52 53
free_text: type: "c", loc.begin: 52 53, loc.end: 52 59, text: "miles"
inner_c_end: loc.begin: 52 53, loc.end: 52 59
free_text: type: "tex", loc.begin: 52 59, loc.end: 54 2, text: " subroutine,
found in the {\sc GB\_\,MILES} module. As explained there,
"
inner_c_begin: loc.begin: 52 59, loc.end: 54 2
free_text: type: "c", loc.begin: 54 2, loc.end: 54 65, text: "miles(n,north_weight,west_weight,pop_weight,0,max_degree,seed)"
inner_c_end: loc.begin: 54 2, loc.end: 54 65
free_text: type: "tex", loc.begin: 54 65, loc.end: 55 11, text: " produces a
graph of "
inner_c_begin: loc.begin: 54 65, loc.end: 55 11
free_text: type: "c", loc.begin: 55 11, loc.end: 55 18, text: "n<=128"
inner_c_end: loc.begin: 55 11, loc.end: 55 18
free_text: type: "tex", loc.begin: 55 18, loc.end: 56 44, text: " vertices based on the driving distances between
North American cities. By default we take "
inner_c_begin: loc.begin: 55 18, loc.end: 56 44
free_text: type: "c", loc.begin: 56 44, loc.end: 56 50, text: "n=100"
inner_c_end: loc.begin: 56 44, loc.end: 56 50
free_text: type: "tex", loc.begin: 56 50, loc.end: 56 53, text: ", "
inner_c_begin: loc.begin: 56 50, loc.end: 56 53
free_text: type: "c", loc.begin: 56 53, loc.end: 57 15, text: "north_weight=west_weight
=pop_weight=0"
inner_c_end: loc.begin: 56 53, loc.end: 57 15
free_text: type: "tex", loc.begin: 57 15, loc.end: 57 22, text: ", and "
inner_c_begin: loc.begin: 57 15, loc.end: 57 22
free_text: type: "c", loc.begin: 57 22, loc.end: 57 36, text: "max_degree=10"
inner_c_end: loc.begin: 57 22, loc.end: 57 36
free_text: type: "tex", loc.begin: 57 36, loc.end: 58 25, text: "; this gives billions of different sparse
graphs, when different "
inner_c_begin: loc.begin: 57 36, loc.end: 58 25
free_text: type: "c", loc.begin: 58 25, loc.end: 58 30, text: "seed"
inner_c_end: loc.begin: 58 25, loc.end: 58 30
free_text: type: "tex", loc.begin: 58 30, loc.end: 64 56, text: " values are specified, since a different
random number seed generally results in the selection of another
one of the $\,128\,\choose100$ possible subgraphs.

The default parameters can be changed by specifying options on the
command line, at least in a \UNIX/ implementation, thereby obtaining a
variety of special effects. For example, the value of "
inner_c_begin: loc.begin: 58 30, loc.end: 64 56
free_text: type: "c", loc.begin: 64 56, loc.end: 64 58, text: "n"
inner_c_end: loc.begin: 64 56, loc.end: 64 58
free_text: type: "tex", loc.begin: 64 58, loc.end: 68 13, text: " can be
raised or lowered and/or the graph can be made more or less sparse.
The user can bias the selection by ranking cities according to their
population and/or position, if nonzero values are given to any of the
parameters "
inner_c_begin: loc.begin: 64 58, loc.end: 68 13
free_text: type: "c", loc.begin: 68 13, loc.end: 68 26, text: "north_weight"
inner_c_end: loc.begin: 68 13, loc.end: 68 26
free_text: type: "tex", loc.begin: 68 26, loc.end: 68 29, text: ", "
inner_c_begin: loc.begin: 68 26, loc.end: 68 29
free_text: type: "c", loc.begin: 68 29, loc.end: 68 41, text: "west_weight"
inner_c_end: loc.begin: 68 29, loc.end: 68 41
free_text: type: "tex", loc.begin: 68 41, loc.end: 68 47, text: ", or "
inner_c_begin: loc.begin: 68 41, loc.end: 68 47
free_text: type: "c", loc.begin: 68 47, loc.end: 68 58, text: "pop_weight"
inner_c_end: loc.begin: 68 47, loc.end: 68 58
free_text: type: "tex", loc.begin: 68 58, loc.end: 71 70, text: ".
Command-line options \.{-n}\<number>, \.{-N}\<number>, \.{-W}\<number>,
\.{-P}\<number>, \.{-d}\<number>, and \.{-s}\<number>
are used to specify non-default values of the respective quantities "
inner_c_begin: loc.begin: 68 58, loc.end: 71 70
free_text: type: "c", loc.begin: 71 70, loc.end: 71 72, text: "n"
inner_c_end: loc.begin: 71 70, loc.end: 71 72
free_text: type: "tex", loc.begin: 71 72, loc.end: 72 2, text: ",
"
inner_c_begin: loc.begin: 71 72, loc.end: 72 2
free_text: type: "c", loc.begin: 72 2, loc.end: 72 15, text: "north_weight"
inner_c_end: loc.begin: 72 2, loc.end: 72 15
free_text: type: "tex", loc.begin: 72 15, loc.end: 72 18, text: ", "
inner_c_begin: loc.begin: 72 15, loc.end: 72 18
free_text: type: "c", loc.begin: 72 18, loc.end: 72 30, text: "west_weight"
inner_c_end: loc.begin: 72 18, loc.end: 72 30
free_text: type: "tex", loc.begin: 72 30, loc.end: 72 33, text: ", "
inner_c_begin: loc.begin: 72 30, loc.end: 72 33
free_text: type: "c", loc.begin: 72 33, loc.end: 72 44, text: "pop_weight"
inner_c_end: loc.begin: 72 33, loc.end: 72 44
free_text: type: "tex", loc.begin: 72 44, loc.end: 72 47, text: ", "
inner_c_begin: loc.begin: 72 44, loc.end: 72 47
free_text: type: "c", loc.begin: 72 47, loc.end: 72 58, text: "max_degree"
inner_c_end: loc.begin: 72 47, loc.end: 72 58
free_text: type: "tex", loc.begin: 72 58, loc.end: 72 65, text: ", and "
inner_c_begin: loc.begin: 72 58, loc.end: 72 65
free_text: type: "c", loc.begin: 72 65, loc.end: 72 70, text: "seed"
inner_c_end: loc.begin: 72 65, loc.end: 72 70
free_text: type: "tex", loc.begin: 72 70, loc.end: 76 47, text: ".

If the user specifies a \.{-r} option, for example by saying `\.{miles\_span}
\.{-r10}', this program will investigate the spanning trees of a
series of, say, 10 graphs having consecutive "
inner_c_begin: loc.begin: 72 70, loc.end: 76 47
free_text: type: "c", loc.begin: 76 47, loc.end: 76 52, text: "seed"
inner_c_end: loc.begin: 76 47, loc.end: 76 52
free_text: type: "tex", loc.begin: 76 52, loc.end: 77 29, text: " values. (This
option makes sense only if "
inner_c_begin: loc.begin: 76 52, loc.end: 77 29
free_text: type: "c", loc.begin: 77 29, loc.end: 77 67, text: "north_weight=west_weight=pop_weight=0"
inner_c_end: loc.begin: 77 29, loc.end: 77 67
free_text: type: "tex", loc.begin: 77 67, loc.end: 78 10, text: ",
because "
inner_c_begin: loc.begin: 77 67, loc.end: 78 10
free_text: type: "c", loc.begin: 78 10, loc.end: 78 16, text: "miles"
inner_c_end: loc.begin: 78 10, loc.end: 78 16
free_text: type: "tex", loc.begin: 78 16, loc.end: 78 34, text: " chooses the top "
inner_c_begin: loc.begin: 78 16, loc.end: 78 34
free_text: type: "c", loc.begin: 78 34, loc.end: 78 36, text: "n"
inner_c_end: loc.begin: 78 34, loc.end: 78 36
free_text: type: "tex", loc.begin: 78 36, loc.end: 84 2, text: " cities by weight. The procedure rarely
needs to use random numbers to break ties when the weights are nonzero,
because cities rarely have exactly the same weight in that case.)

The special command-line option \.{-g}$\langle\,$filename$\,\rangle$
overrides all others. It substitutes an external graph previously saved by
"
inner_c_begin: loc.begin: 78 36, loc.end: 84 2
free_text: type: "c", loc.begin: 84 2, loc.end: 84 13, text: "save_graph"
inner_c_end: loc.begin: 84 2, loc.end: 84 13
free_text: type: "tex", loc.begin: 84 13, loc.end: 84 42, text: " for the graphs produced by "
inner_c_begin: loc.begin: 84 13, loc.end: 84 42
free_text: type: "c", loc.begin: 84 42, loc.end: 84 48, text: "miles"
inner_c_end: loc.begin: 84 42, loc.end: 84 48
index_entry: entry: "UNIX dependencies", loc.begin: 84 48, loc.end: 86 22
tex_section_end: loc.begin: 86 22, loc.end: 90 3
tex_end: loc.begin: 86 22, loc.end: 90 3
c_begin: loc.begin: 86 22, loc.end: 90 3
unnamed_c_section_begin:
free_text: type: "c", loc.begin: 90 3, loc.end: 91 11, text: "
#include "
string_begin: type: "c", loc.begin: 90 3, loc.end: 91 11
free_text: type: "tex", loc.begin: 91 11, loc.end: 91 22, text: "gb_graph.h"
string_end: type: "c", loc.begin: 91 11, loc.end: 91 22
free_text: type: "c", loc.begin: 91 22, loc.end: 91 25, text: " "
comment_begin: type: "c", loc.begin: 91 22, loc.end: 91 25
free_text: type: "tex", loc.begin: 91 25, loc.end: 91 58, text: " the GraphBase data structures "
comment_end: type: "c", loc.begin: 91 25, loc.end: 91 58
free_text: type: "c", loc.begin: 91 58, loc.end: 92 11, text: "
#include "
string_begin: type: "c", loc.begin: 91 58, loc.end: 92 11
free_text: type: "tex", loc.begin: 92 11, loc.end: 92 21, text: "gb_save.h"
string_end: type: "c", loc.begin: 92 11, loc.end: 92 21
free_text: type: "c", loc.begin: 92 21, loc.end: 92 24, text: " "
comment_begin: type: "c", loc.begin: 92 21, loc.end: 92 24
free_text: type: "tex", loc.begin: 92 24, loc.end: 92 26, text: " "
inner_c_begin: loc.begin: 92 24, loc.end: 92 26
free_text: type: "c", loc.begin: 92 26, loc.end: 92 40, text: "restore_graph"
inner_c_end: loc.begin: 92 26, loc.end: 92 40
free_text: type: "tex", loc.begin: 92 40, loc.end: 92 43, text: " "
comment_end: type: "c", loc.begin: 92 40, loc.end: 92 43
free_text: type: "c", loc.begin: 92 43, loc.end: 93 11, text: "
#include "
string_begin: type: "c", loc.begin: 92 43, loc.end: 93 11
free_text: type: "tex", loc.begin: 93 11, loc.end: 93 22, text: "gb_miles.h"
string_end: type: "c", loc.begin: 93 11, loc.end: 93 22
free_text: type: "c", loc.begin: 93 22, loc.end: 93 25, text: " "
comment_begin: type: "c", loc.begin: 93 22, loc.end: 93 25
free_text: type: "tex", loc.begin: 93 25, loc.end: 93 31, text: " the "
inner_c_begin: loc.begin: 93 25, loc.end: 93 31
free_text: type: "c", loc.begin: 93 31, loc.end: 93 37, text: "miles"
inner_c_end: loc.begin: 93 31, loc.end: 93 37
free_text: type: "tex", loc.begin: 93 37, loc.end: 93 48, text: " routine "
comment_end: type: "c", loc.begin: 93 37, loc.end: 93 48
emit_macros_here: loc.begin: 93 48, loc.end: 94 3
c_format: code: "@#"
section_name: name: "Global variables", isPrefix: loc.begin: 94 5, loc.end: 95 3, false
c_format: code: "@;"
section_name: name: "Procedures to be declared early", isPrefix: loc.begin: 95 5, loc.end: 96 3, false
c_format: code: "@;"
section_name: name: "Priority queue subroutines", isPrefix: loc.begin: 96 5, loc.end: 97 3, false
c_format: code: "@;"
section_name: name: "Subroutines", isPrefix: loc.begin: 97 5, loc.end: 98 3, false
c_format: code: "@;"
free_text: type: "c", loc.begin: 98 5, loc.end: 100 15, text: "
main(argc,argv)
  int argc; "
comment_begin: type: "c", loc.begin: 98 5, loc.end: 100 15
free_text: type: "tex", loc.begin: 100 15, loc.end: 100 55, text: " the number of command-line arguments "
comment_end: type: "c", loc.begin: 100 15, loc.end: 100 55
free_text: type: "c", loc.begin: 100 55, loc.end: 101 19, text: "
  char *argv[]; "
comment_begin: type: "c", loc.begin: 100 55, loc.end: 101 19
free_text: type: "tex", loc.begin: 101 19, loc.end: 101 69, text: " an array of strings containing those arguments "
comment_end: type: "c", loc.begin: 101 19, loc.end: 101 69
c_format: code: "@+"
free_text: type: "c", loc.begin: 102 4, loc.end: 102 27, text: "unsigned long n=100; "
comment_begin: type: "c", loc.begin: 102 4, loc.end: 102 27
free_text: type: "tex", loc.begin: 102 27, loc.end: 102 61, text: " the desired number of vertices "
comment_end: type: "c", loc.begin: 102 27, loc.end: 102 61
free_text: type: "c", loc.begin: 102 61, loc.end: 103 31, text: "
  unsigned long n_weight=0; "
comment_begin: type: "c", loc.begin: 102 61, loc.end: 103 31
free_text: type: "tex", loc.begin: 103 31, loc.end: 103 37, text: " the "
inner_c_begin: loc.begin: 103 31, loc.end: 103 37
free_text: type: "c", loc.begin: 103 37, loc.end: 103 50, text: "north_weight"
inner_c_end: loc.begin: 103 37, loc.end: 103 50
free_text: type: "tex", loc.begin: 103 50, loc.end: 103 63, text: " parameter "
comment_end: type: "c", loc.begin: 103 50, loc.end: 103 63
free_text: type: "c", loc.begin: 103 63, loc.end: 104 31, text: "
  unsigned long w_weight=0; "
comment_begin: type: "c", loc.begin: 103 63, loc.end: 104 31
free_text: type: "tex", loc.begin: 104 31, loc.end: 104 37, text: " the "
inner_c_begin: loc.begin: 104 31, loc.end: 104 37
free_text: type: "c", loc.begin: 104 37, loc.end: 104 49, text: "west_weight"
inner_c_end: loc.begin: 104 37, loc.end: 104 49
free_text: type: "tex", loc.begin: 104 49, loc.end: 104 62, text: " parameter "
comment_end: type: "c", loc.begin: 104 49, loc.end: 104 62
free_text: type: "c", loc.begin: 104 62, loc.end: 105 31, text: "
  unsigned long p_weight=0; "
comment_begin: type: "c", loc.begin: 104 62, loc.end: 105 31
free_text: type: "tex", loc.begin: 105 31, loc.end: 105 37, text: " the "
inner_c_begin: loc.begin: 105 31, loc.end: 105 37
free_text: type: "c", loc.begin: 105 37, loc.end: 105 48, text: "pop_weight"
inner_c_end: loc.begin: 105 37, loc.end: 105 48
free_text: type: "tex", loc.begin: 105 48, loc.end: 105 61, text: " parameter "
comment_end: type: "c", loc.begin: 105 48, loc.end: 105 61
free_text: type: "c", loc.begin: 105 61, loc.end: 106 25, text: "
  unsigned long d=10; "
comment_begin: type: "c", loc.begin: 105 61, loc.end: 106 25
free_text: type: "tex", loc.begin: 106 25, loc.end: 106 31, text: " the "
inner_c_begin: loc.begin: 106 25, loc.end: 106 31
free_text: type: "c", loc.begin: 106 31, loc.end: 106 42, text: "max_degree"
inner_c_end: loc.begin: 106 31, loc.end: 106 42
free_text: type: "tex", loc.begin: 106 42, loc.end: 106 55, text: " parameter "
comment_end: type: "c", loc.begin: 106 42, loc.end: 106 55
free_text: type: "c", loc.begin: 106 55, loc.end: 107 15, text: "
  long s=0; "
comment_begin: type: "c", loc.begin: 106 55, loc.end: 107 15
free_text: type: "tex", loc.begin: 107 15, loc.end: 107 41, text: " the random number seed "
comment_end: type: "c", loc.begin: 107 15, loc.end: 107 41
free_text: type: "c", loc.begin: 107 41, loc.end: 108 24, text: "
  unsigned long r=1; "
comment_begin: type: "c", loc.begin: 107 41, loc.end: 108 24
free_text: type: "tex", loc.begin: 108 24, loc.end: 108 53, text: " the number of repetitions "
comment_end: type: "c", loc.begin: 108 24, loc.end: 108 53
free_text: type: "c", loc.begin: 108 53, loc.end: 109 27, text: "
  char *file_name=NULL; "
comment_begin: type: "c", loc.begin: 108 53, loc.end: 109 27
free_text: type: "tex", loc.begin: 109 27, loc.end: 109 60, text: " external graph to be restored "
comment_end: type: "c", loc.begin: 109 27, loc.end: 109 60
section_name: name: "Scan the command-line options", isPrefix: loc.begin: 109 60, loc.end: 110 5, false
free_text: type: "c", loc.begin: 110 5, loc.end: 115 23, text: ";
  while (r--) {
    if (file_name) g=restore_graph(file_name);
    else g=miles(n,n_weight,w_weight,p_weight,0L,d,s);
    if (g==NULL || g->n<=1) {
      fprintf(stderr,"
string_begin: type: "c", loc.begin: 110 5, loc.end: 115 23
free_text: type: "tex", loc.begin: 115 23, loc.end: 115 73, text: "Sorry, can't create the graph! (error code %ld)\n"
string_end: type: "c", loc.begin: 115 23, loc.end: 115 73
free_text: type: "c", loc.begin: 115 73, loc.end: 117 20, text: ",
               panic_code);
      return -1; "
comment_begin: type: "c", loc.begin: 115 73, loc.end: 117 20
free_text: type: "tex", loc.begin: 117 20, loc.end: 117 65, text: " error code 0 means the graph is too small "
comment_end: type: "c", loc.begin: 117 20, loc.end: 117 65
section_name: name: "Report the number of mems needed to compute a minimum spanning tree
       of |g| by various algorithms", isPrefix: loc.begin: 117 65, loc.end: 119 7, false
free_text: type: "c", loc.begin: 119 7, loc.end: 121 12, text: ";
    gb_recycle(g);
    s++; "
comment_begin: type: "c", loc.begin: 119 7, loc.end: 121 12
free_text: type: "tex", loc.begin: 121 12, loc.end: 121 27, text: " increase the "
inner_c_begin: loc.begin: 121 12, loc.end: 121 27
free_text: type: "c", loc.begin: 121 27, loc.end: 121 32, text: "seed"
inner_c_end: loc.begin: 121 27, loc.end: 121 32
free_text: type: "tex", loc.begin: 121 32, loc.end: 121 41, text: " value "
comment_end: type: "c", loc.begin: 121 32, loc.end: 121 41
free_text: type: "c", loc.begin: 121 41, loc.end: 123 15, text: "
  }
  return 0; "
comment_begin: type: "c", loc.begin: 121 41, loc.end: 123 15
free_text: type: "tex", loc.begin: 123 15, loc.end: 123 30, text: " normal exit "
comment_end: type: "c", loc.begin: 123 15, loc.end: 123 30
free_text: type: "c", loc.begin: 123 30, loc.end: 126 3, text: "
}

@ "
c_end: loc.begin: 123 30, loc.end: 126 3
tex_begin: loc.begin: 123 30, loc.end: 126 3
tex_section_begin: type: "unstarred", loc.begin: 123 30, loc.end: 126 3
tex_section_end: loc.begin: 126 3, loc.end: 126 5
tex_end: loc.begin: 126 3, loc.end: 126 5
c_begin: loc.begin: 126 3, loc.end: 126 5
named_section_begin: name: "Global...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 126 5, loc.end: 127 13, text: "
Graph *g; "
comment_begin: type: "c", loc.begin: 126 5, loc.end: 127 13
free_text: type: "tex", loc.begin: 127 13, loc.end: 127 42, text: " the graph we will work on "
comment_end: type: "c", loc.begin: 127 13, loc.end: 127 42
free_text: type: "c", loc.begin: 127 42, loc.end: 129 3, text: "

@ "
named_section_end: loc.begin: 127 42, loc.end: 129 3
c_end: loc.begin: 127 42, loc.end: 129 3
tex_begin: loc.begin: 127 42, loc.end: 129 3
tex_section_begin: type: "unstarred", loc.begin: 127 42, loc.end: 129 3
tex_section_end: loc.begin: 129 3, loc.end: 129 5
tex_end: loc.begin: 129 3, loc.end: 129 5
c_begin: loc.begin: 129 3, loc.end: 129 5
named_section_begin: name: "Scan the command-line options", isPrefix: false, isContinuation: "false"
index_entry: entry: "UNIX dependencies", loc.begin: 129 5, loc.end: 131 22
free_text: type: "c", loc.begin: 131 22, loc.end: 132 26, text: "
  if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 131 22, loc.end: 132 26
free_text: type: "tex", loc.begin: 132 26, loc.end: 132 32, text: "-n%lu"
string_end: type: "c", loc.begin: 132 26, loc.end: 132 32
free_text: type: "c", loc.begin: 132 32, loc.end: 133 31, text: ",&n)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 132 32, loc.end: 133 31
free_text: type: "tex", loc.begin: 133 31, loc.end: 133 37, text: "-N%lu"
string_end: type: "c", loc.begin: 133 31, loc.end: 133 37
free_text: type: "c", loc.begin: 133 37, loc.end: 134 31, text: ",&n_weight)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 133 37, loc.end: 134 31
free_text: type: "tex", loc.begin: 134 31, loc.end: 134 37, text: "-W%lu"
string_end: type: "c", loc.begin: 134 31, loc.end: 134 37
free_text: type: "c", loc.begin: 134 37, loc.end: 135 31, text: ",&w_weight)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 134 37, loc.end: 135 31
free_text: type: "tex", loc.begin: 135 31, loc.end: 135 37, text: "-P%lu"
string_end: type: "c", loc.begin: 135 31, loc.end: 135 37
free_text: type: "c", loc.begin: 135 37, loc.end: 136 31, text: ",&p_weight)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 135 37, loc.end: 136 31
free_text: type: "tex", loc.begin: 136 31, loc.end: 136 37, text: "-d%lu"
string_end: type: "c", loc.begin: 136 31, loc.end: 136 37
free_text: type: "c", loc.begin: 136 37, loc.end: 137 31, text: ",&d)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 136 37, loc.end: 137 31
free_text: type: "tex", loc.begin: 137 31, loc.end: 137 37, text: "-r%lu"
string_end: type: "c", loc.begin: 137 31, loc.end: 137 37
free_text: type: "c", loc.begin: 137 37, loc.end: 138 31, text: ",&r)==1) ;
  else if (sscanf(argv[argc],"
string_begin: type: "c", loc.begin: 137 37, loc.end: 138 31
free_text: type: "tex", loc.begin: 138 31, loc.end: 138 37, text: "-s%ld"
string_end: type: "c", loc.begin: 138 31, loc.end: 138 37
free_text: type: "c", loc.begin: 138 37, loc.end: 139 31, text: ",&s)==1) ;
  else if (strcmp(argv[argc],"
string_begin: type: "c", loc.begin: 138 37, loc.end: 139 31
free_text: type: "tex", loc.begin: 139 31, loc.end: 139 34, text: "-v"
string_end: type: "c", loc.begin: 139 31, loc.end: 139 34
free_text: type: "c", loc.begin: 139 34, loc.end: 140 32, text: ")==0) verbose=1;
  else if (strncmp(argv[argc],"
string_begin: type: "c", loc.begin: 139 34, loc.end: 140 32
free_text: type: "tex", loc.begin: 140 32, loc.end: 140 35, text: "-g"
string_end: type: "c", loc.begin: 140 32, loc.end: 140 35
free_text: type: "c", loc.begin: 140 35, loc.end: 143 15, text: ",2)==0) file_name=argv[argc]+2;
  else {
    fprintf(stderr,
             "
string_begin: type: "c", loc.begin: 140 35, loc.end: 143 15
free_text: type: "tex", loc.begin: 143 15, loc.end: 143 74, text: "Usage: %s [-nN][-dN][-rN][-sN][-NN][-WN][-PN][-v][-gfoo]\n"
string_end: type: "c", loc.begin: 143 15, loc.end: 143 74
free_text: type: "c", loc.begin: 143 74, loc.end: 150 3, text: ",
             argv[0]);
    return -2;
  }
}
if (file_name) r=1;

@ "
named_section_end: loc.begin: 143 74, loc.end: 150 3
c_end: loc.begin: 143 74, loc.end: 150 3
tex_begin: loc.begin: 143 74, loc.end: 150 3
tex_section_begin: type: "unstarred", loc.begin: 143 74, loc.end: 150 3
free_text: type: "tex", loc.begin: 150 3, loc.end: 152 9, text: "We will try out four basic algorithms that have received prominent
attention in the literature. Graham and Hell's Algorithm~1 is represented
by the "
inner_c_begin: loc.begin: 150 3, loc.end: 152 9
free_text: type: "c", loc.begin: 152 9, loc.end: 152 15, text: "krusk"
inner_c_end: loc.begin: 152 9, loc.end: 152 15
free_text: type: "tex", loc.begin: 152 15, loc.end: 154 24, text: " procedure, which uses Kruskal's algorithm after the
edges have been sorted by length with a radix sort. Their Algorithm~2
is represented by the "
inner_c_begin: loc.begin: 152 15, loc.end: 154 24
free_text: type: "c", loc.begin: 154 24, loc.end: 154 31, text: "jar_pr"
inner_c_end: loc.begin: 154 24, loc.end: 154 31
free_text: type: "tex", loc.begin: 154 31, loc.end: 157 24, text: " procedure, which incorporates a 
priority queue structure that we implement in two ways, either as
a simple binary heap or as a Fibonacci heap. And their Algorithm~3
is represented by the "
inner_c_begin: loc.begin: 154 31, loc.end: 157 24
free_text: type: "c", loc.begin: 157 24, loc.end: 157 37, text: "cher_tar_kar"
inner_c_end: loc.begin: 157 24, loc.end: 157 37
index_entry: entry: "Cheriton, David Ross", loc.begin: 157 37, loc.end: 161 25
index_entry: entry: "Tarjan, Robert Endre", loc.begin: 161 25, loc.end: 162 25
index_entry: entry: "Karp, Richard Manning", loc.begin: 162 25, loc.end: 163 26
tex_section_end: loc.begin: 163 26, loc.end: 165 3
tex_end: loc.begin: 163 26, loc.end: 165 3
middle_begin: loc.begin: 163 26, loc.end: 165 3
macro_begin: name: "INFINITY", params: {}, loc.begin: 165 3, loc.end: 168 3, text: "INFINITY "
macro_end: loc.begin: 165 3, loc.end: 168 3
middle_end: loc.begin: 165 3, loc.end: 168 3
c_begin: loc.begin: 165 3, loc.end: 168 3
named_section_begin: name: "Report the number...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 168 3, loc.end: 169 9, text: "
printf("
string_begin: type: "c", loc.begin: 168 3, loc.end: 169 9
free_text: type: "tex", loc.begin: 169 9, loc.end: 169 39, text: "The graph %s has %ld edges,\n"
string_end: type: "c", loc.begin: 169 9, loc.end: 169 39
free_text: type: "c", loc.begin: 169 39, loc.end: 171 34, text: ",g->id,g->m/2);
sp_length=krusk(g);
if (sp_length==INFINITY) printf("
string_begin: type: "c", loc.begin: 169 39, loc.end: 171 34
free_text: type: "tex", loc.begin: 171 34, loc.end: 171 62, text: "  and it isn't connected.\n"
string_end: type: "c", loc.begin: 171 34, loc.end: 171 62
free_text: type: "c", loc.begin: 171 62, loc.end: 172 14, text: ");
else printf("
string_begin: type: "c", loc.begin: 171 62, loc.end: 172 14
free_text: type: "tex", loc.begin: 172 14, loc.end: 172 64, text: "  and its minimum spanning tree has length %ld.\n"
string_end: type: "c", loc.begin: 172 14, loc.end: 172 64
free_text: type: "c", loc.begin: 172 64, loc.end: 173 9, text: ",sp_length);
printf("
string_begin: type: "c", loc.begin: 172 64, loc.end: 173 9
free_text: type: "tex", loc.begin: 173 9, loc.end: 173 61, text: " The Kruskal/radix-sort algorithm takes %ld mems;\n"
string_end: type: "c", loc.begin: 173 9, loc.end: 173 61
section_name: name: "Execute |jar_pr(g)| with binary heaps as the priority queue algorithm", isPrefix: loc.begin: 173 61, loc.end: 174 3, false
free_text: type: "c", loc.begin: 174 3, loc.end: 175 9, text: ";
printf("
string_begin: type: "c", loc.begin: 174 3, loc.end: 175 9
free_text: type: "tex", loc.begin: 175 9, loc.end: 175 66, text: " the Jarnik/Prim/binary-heap algorithm takes %ld mems;\n"
string_end: type: "c", loc.begin: 175 9, loc.end: 175 66
section_name: name: "Allocate additional space needed by the more complex algorithms;
    or |goto done| if there isn't enough room", isPrefix: loc.begin: 175 66, loc.end: 176 3, false
section_name: name: "Execute |jar_pr(g)| with Fibonacci heaps as
     the priority queue algorithm", isPrefix: loc.begin: 176 3, loc.end: 177 3, false
free_text: type: "c", loc.begin: 177 3, loc.end: 178 9, text: ";
printf("
string_begin: type: "c", loc.begin: 177 3, loc.end: 178 9
free_text: type: "tex", loc.begin: 178 9, loc.end: 178 69, text: " the Jarnik/Prim/Fibonacci-heap algorithm takes %ld mems;\n"
string_end: type: "c", loc.begin: 178 9, loc.end: 178 69
free_text: type: "c", loc.begin: 178 69, loc.end: 180 32, text: ",mems);
if (sp_length!=cher_tar_kar(g)) {
  if (gb_trouble_code) printf("
string_begin: type: "c", loc.begin: 178 69, loc.end: 180 32
free_text: type: "tex", loc.begin: 180 32, loc.end: 180 68, text: " ...oops, I've run out of memory!\n"
string_end: type: "c", loc.begin: 180 32, loc.end: 180 68
free_text: type: "c", loc.begin: 180 68, loc.end: 181 16, text: ");
  else printf("
string_begin: type: "c", loc.begin: 180 68, loc.end: 181 16
free_text: type: "tex", loc.begin: 181 16, loc.end: 181 63, text: " ...oops, I've got a bug, please fix fix fix\n"
string_end: type: "c", loc.begin: 181 16, loc.end: 181 63
free_text: type: "c", loc.begin: 181 63, loc.end: 184 9, text: ");
  return -3;
}
printf("
string_begin: type: "c", loc.begin: 181 63, loc.end: 184 9
free_text: type: "tex", loc.begin: 184 9, loc.end: 184 65, text: " the Cheriton/Tarjan/Karp algorithm takes %ld mems.\n\n"
string_end: type: "c", loc.begin: 184 9, loc.end: 184 65
free_text: type: "c", loc.begin: 184 65, loc.end: 187 3, text: ",mems);
done:;

@ "
named_section_end: loc.begin: 184 65, loc.end: 187 3
c_end: loc.begin: 184 65, loc.end: 187 3
tex_begin: loc.begin: 184 65, loc.end: 187 3
tex_section_begin: type: "unstarred", loc.begin: 184 65, loc.end: 187 3
tex_section_end: loc.begin: 187 3, loc.end: 187 5
tex_end: loc.begin: 187 3, loc.end: 187 5
c_begin: loc.begin: 187 3, loc.end: 187 5
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 187 5, loc.end: 188 28, text: "
unsigned long sp_length; "
comment_begin: type: "c", loc.begin: 187 5, loc.end: 188 28
free_text: type: "tex", loc.begin: 188 28, loc.end: 188 67, text: " length of the minimum spanning tree "
comment_end: type: "c", loc.begin: 188 28, loc.end: 188 67
free_text: type: "c", loc.begin: 188 67, loc.end: 190 3, text: "

@ "
named_section_end: loc.begin: 188 67, loc.end: 190 3
c_end: loc.begin: 188 67, loc.end: 190 3
tex_begin: loc.begin: 188 67, loc.end: 190 3
tex_section_begin: type: "unstarred", loc.begin: 188 67, loc.end: 190 3
free_text: type: "tex", loc.begin: 190 3, loc.end: 190 13, text: "When the "
inner_c_begin: loc.begin: 190 3, loc.end: 190 13
free_text: type: "c", loc.begin: 190 13, loc.end: 190 21, text: "verbose"
inner_c_end: loc.begin: 190 13, loc.end: 190 21
free_text: type: "tex", loc.begin: 190 21, loc.end: 191 27, text: " switch is nonzero, edges found by the various
algorithms will call the "
inner_c_begin: loc.begin: 190 21, loc.end: 191 27
free_text: type: "c", loc.begin: 191 27, loc.end: 191 34, text: "report"
inner_c_end: loc.begin: 191 27, loc.end: 191 34
tex_section_end: loc.begin: 191 34, loc.end: 193 3
tex_end: loc.begin: 191 34, loc.end: 193 3
c_begin: loc.begin: 191 34, loc.end: 193 3
named_section_begin: name: "Sub...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 193 3, loc.end: 195 19, text: "
report(u,v,l)
  Vertex *u,*v; "
comment_begin: type: "c", loc.begin: 193 3, loc.end: 195 19
free_text: type: "tex", loc.begin: 195 19, loc.end: 195 69, text: " adjacent vertices in the minimum spanning tree "
comment_end: type: "c", loc.begin: 195 19, loc.end: 195 69
free_text: type: "c", loc.begin: 195 69, loc.end: 196 13, text: "
  long l; "
comment_begin: type: "c", loc.begin: 195 69, loc.end: 196 13
free_text: type: "tex", loc.begin: 196 13, loc.end: 196 52, text: " the length of the edge between them "
comment_end: type: "c", loc.begin: 196 13, loc.end: 196 52
free_text: type: "c", loc.begin: 196 52, loc.end: 197 11, text: "
{ printf("
string_begin: type: "c", loc.begin: 196 52, loc.end: 197 11
free_text: type: "tex", loc.begin: 197 11, loc.end: 197 54, text: "  %ld miles between %s and %s [%ld mems]\n"
string_end: type: "c", loc.begin: 197 11, loc.end: 197 54
free_text: type: "c", loc.begin: 197 54, loc.end: 201 31, text: ",
           l,u->name,v->name,mems);
}

@*"
named_section_end: loc.begin: 197 54, loc.end: 201 31
c_end: loc.begin: 197 54, loc.end: 201 31
tex_begin: loc.begin: 197 54, loc.end: 201 31
tex_section_begin: type: "starred", title: "Strategies and ground rules.", loc.begin: 197 54, loc.end: 201 31
index_entry: entry: "Prim, Robert Clay", loc.begin: 201 31, loc.end: 205 22
free_text: type: "tex", loc.begin: 205 22, loc.end: 216 3, text: "
``If a fragment~$F$ does not include all the vertices, and if $e$~is
a shortest edge joining $F$ to a vertex not in~$F$, then $F\cup e$
is a fragment.'' To prove Prim's principle, let $T$ be a minimum
spanning tree that contains $F$ but not~$e$. Adding $e$ to~$T$ creates
a circuit containing some edge $e'\ne e$, where $e'$ runs from a vertex
in~$F$ to a vertex not in~$F$. Deleting $e'$ from
$T\cup e$ produces a spanning tree~$T'$ of total length no larger
than the total length of~$T$. Hence $T'$ is a minimum spanning
tree containing $F\cup e$, QED.

@ "
tex_section_end: loc.begin: 205 22, loc.end: 216 3
tex_end: loc.begin: 205 22, loc.end: 216 3
tex_begin: loc.begin: 205 22, loc.end: 216 3
tex_section_begin: type: "unstarred", loc.begin: 205 22, loc.end: 216 3
free_text: type: "tex", loc.begin: 216 3, loc.end: 216 27, text: "The graphs produced by "
inner_c_begin: loc.begin: 216 3, loc.end: 216 27
free_text: type: "c", loc.begin: 216 27, loc.end: 216 33, text: "miles"
inner_c_end: loc.begin: 216 27, loc.end: 216 33
free_text: type: "tex", loc.begin: 216 33, loc.end: 222 25, text: " have special properties, and it is fair game
to make use of those properties if we can.

First, the length of each edge is a positive integer less than $2^{12}$.

Second, the $k$th vertex $v_k$ of the graph is represented in \CEE/ programs by
the pointer expression "
inner_c_begin: loc.begin: 216 33, loc.end: 222 25
free_text: type: "c", loc.begin: 222 25, loc.end: 222 39, text: "g->vertices+k"
inner_c_end: loc.begin: 222 25, loc.end: 222 39
free_text: type: "tex", loc.begin: 222 39, loc.end: 223 61, text: ". If weights have been assigned,
these vertices will be in order by weight. For example, if "
inner_c_begin: loc.begin: 222 39, loc.end: 223 61
free_text: type: "c", loc.begin: 223 61, loc.end: 223 76, text: "north_weight=1"
inner_c_end: loc.begin: 223 61, loc.end: 223 76
free_text: type: "tex", loc.begin: 223 76, loc.end: 224 6, text: "
but "
inner_c_begin: loc.begin: 223 76, loc.end: 224 6
free_text: type: "c", loc.begin: 224 6, loc.end: 224 31, text: "west_weight=pop_weight=0"
inner_c_end: loc.begin: 224 6, loc.end: 224 31
free_text: type: "tex", loc.begin: 224 31, loc.end: 227 44, text: ", vertex $v_0$ will be the most northerly city
and vertex $v_{n-1}$ will be the most southerly.

Third, the edges accessible from a vertex "
inner_c_begin: loc.begin: 224 31, loc.end: 227 44
free_text: type: "c", loc.begin: 227 44, loc.end: 227 46, text: "v"
inner_c_end: loc.begin: 227 44, loc.end: 227 46
free_text: type: "tex", loc.begin: 227 46, loc.end: 228 14, text: " appear in a linked list
starting at "
inner_c_begin: loc.begin: 227 46, loc.end: 228 14
free_text: type: "c", loc.begin: 228 14, loc.end: 228 22, text: "v->arcs"
inner_c_end: loc.begin: 228 14, loc.end: 228 22
free_text: type: "tex", loc.begin: 228 22, loc.end: 228 38, text: ". An edge from "
inner_c_begin: loc.begin: 228 22, loc.end: 228 38
free_text: type: "c", loc.begin: 228 38, loc.end: 228 40, text: "v"
inner_c_end: loc.begin: 228 38, loc.end: 228 40
free_text: type: "tex", loc.begin: 228 40, loc.end: 229 12, text: " to $v_j$ will precede an
edge from "
inner_c_begin: loc.begin: 228 40, loc.end: 229 12
free_text: type: "c", loc.begin: 229 12, loc.end: 229 14, text: "v"
inner_c_end: loc.begin: 229 12, loc.end: 229 14
free_text: type: "tex", loc.begin: 229 14, loc.end: 231 40, text: " to $v_k$ in this list if and only if $j>k$.

Fourth, the vertices have coordinates "
inner_c_begin: loc.begin: 229 14, loc.end: 231 40
free_text: type: "c", loc.begin: 231 40, loc.end: 231 51, text: "v->x_coord"
inner_c_end: loc.begin: 231 40, loc.end: 231 51
free_text: type: "tex", loc.begin: 231 51, loc.end: 231 57, text: " and "
inner_c_begin: loc.begin: 231 51, loc.end: 231 57
free_text: type: "c", loc.begin: 231 57, loc.end: 231 68, text: "v->y_coord"
inner_c_end: loc.begin: 231 57, loc.end: 231 68
free_text: type: "tex", loc.begin: 231 68, loc.end: 244 23, text: "
that are correlated with the length of edges between them: The
Euclidean distance between the coordinates of two vertices tends to be small
if and only if those vertices are connected by a relatively short edge.
(This is only a tendency, not a certainty; for example, some cities
around Chesapeake Bay are fairly close together as the crow flies, but not
within easy driving range of each other.)

Fifth, the edge lengths satisfy the triangle inequality: Whenever
three edges form a cycle, the longest is no longer than the sum of
the lengths of the two others. (It can be proved that
the triangle inequality is of no use in finding minimum spanning
trees; we mention it here only to exhibit yet another way in which
the data produced by "
inner_c_begin: loc.begin: 231 68, loc.end: 244 23
free_text: type: "c", loc.begin: 244 23, loc.end: 244 29, text: "miles"
inner_c_end: loc.begin: 244 23, loc.end: 244 29
free_text: type: "tex", loc.begin: 244 29, loc.end: 252 3, text: " is known to be nonrandom.)

Our implementation of Kruskal's algorithm will make use of the first
property, and it also uses part of the third to avoid considering an
edge more than once. We will not exploit the other properties, but a
reader who wants to design algorithms that use fewer mems to find minimum
spanning trees of these graphs is free to use any idea that helps.

@ "
tex_section_end: loc.begin: 244 29, loc.end: 252 3
tex_end: loc.begin: 244 29, loc.end: 252 3
tex_begin: loc.begin: 244 29, loc.end: 252 3
tex_section_begin: type: "unstarred", loc.begin: 244 29, loc.end: 252 3
free_text: type: "tex", loc.begin: 252 3, loc.end: 253 56, text: "Speaking of mems, here are the simple \CEE/ instrumentation macros that we
use to count memory references. The macros are called "
inner_c_begin: loc.begin: 252 3, loc.end: 253 56
free_text: type: "c", loc.begin: 253 56, loc.end: 253 58, text: "o"
inner_c_end: loc.begin: 253 56, loc.end: 253 58
free_text: type: "tex", loc.begin: 253 58, loc.end: 253 61, text: ", "
inner_c_begin: loc.begin: 253 58, loc.end: 253 61
free_text: type: "c", loc.begin: 253 61, loc.end: 253 64, text: "oo"
inner_c_end: loc.begin: 253 61, loc.end: 253 64
free_text: type: "tex", loc.begin: 253 64, loc.end: 253 67, text: ", "
inner_c_begin: loc.begin: 253 64, loc.end: 253 67
free_text: type: "c", loc.begin: 253 67, loc.end: 253 71, text: "ooo"
inner_c_end: loc.begin: 253 67, loc.end: 253 71
free_text: type: "tex", loc.begin: 253 71, loc.end: 254 6, text: ",
and "
inner_c_begin: loc.begin: 253 71, loc.end: 254 6
free_text: type: "c", loc.begin: 254 6, loc.end: 254 11, text: "oooo"
inner_c_end: loc.begin: 254 6, loc.end: 254 11
index_entry: entry: "Bentley, Jon Louis", loc.begin: 254 11, loc.end: 255 23
free_text: type: "tex", loc.begin: 255 23, loc.end: 256 66, text: "
Implementors who want to count mems are supposed to say, e.g., `"
inner_c_begin: loc.begin: 255 23, loc.end: 256 66
free_text: type: "c", loc.begin: 256 66, loc.end: 256 69, text: "oo"
inner_c_end: loc.begin: 256 66, loc.end: 256 69
free_text: type: "tex", loc.begin: 256 69, loc.end: 259 32, text: ",'
just before an assignment statement or boolean expression that makes
two references to memory. The \CEE/ preprocessor will convert this
to a statement that increases "
inner_c_begin: loc.begin: 256 69, loc.end: 259 32
free_text: type: "c", loc.begin: 259 32, loc.end: 259 37, text: "mems"
inner_c_end: loc.begin: 259 32, loc.end: 259 37
free_text: type: "tex", loc.begin: 259 37, loc.end: 263 8, text: " by~2 as that statement or expression
is evaluated.

The semantics of \CEE/ tell us that the evaluation of an expression
like `"
inner_c_begin: loc.begin: 259 37, loc.end: 263 8
free_text: type: "c", loc.begin: 263 8, loc.end: 263 25, text: "a&&(o,a->len>10)"
inner_c_end: loc.begin: 263 8, loc.end: 263 25
free_text: type: "tex", loc.begin: 263 25, loc.end: 263 43, text: "' will increment "
inner_c_begin: loc.begin: 263 25, loc.end: 263 43
free_text: type: "c", loc.begin: 263 43, loc.end: 263 48, text: "mems"
inner_c_end: loc.begin: 263 43, loc.end: 263 48
free_text: type: "tex", loc.begin: 263 48, loc.end: 264 19, text: " if and only if the
pointer variable~"
inner_c_begin: loc.begin: 263 48, loc.end: 264 19
free_text: type: "c", loc.begin: 264 19, loc.end: 264 21, text: "a"
inner_c_end: loc.begin: 264 19, loc.end: 264 21
free_text: type: "tex", loc.begin: 264 21, loc.end: 265 54, text: " is non-null. Warning: The parentheses are very
important in this example, because \CEE/'s operator "
inner_c_begin: loc.begin: 264 21, loc.end: 265 54
free_text: type: "c", loc.begin: 265 54, loc.end: 265 57, text: "&&"
inner_c_end: loc.begin: 265 54, loc.end: 265 57
free_text: type: "tex", loc.begin: 265 57, loc.end: 268 40, text: " (i.e.,
\.{\&\&}) has higher precedence than comma.

Values of significant variables, like "
inner_c_begin: loc.begin: 265 57, loc.end: 268 40
free_text: type: "c", loc.begin: 268 40, loc.end: 268 42, text: "a"
inner_c_end: loc.begin: 268 40, loc.end: 268 42
index_entry: entry: "discussion of \\{mems}", loc.begin: 268 42, loc.end: 273 27
free_text: type: "tex", loc.begin: 273 27, loc.end: 275 27, text: "

\CEE/ does not allow the "
inner_c_begin: loc.begin: 273 27, loc.end: 275 27
free_text: type: "c", loc.begin: 275 27, loc.end: 275 29, text: "o"
inner_c_end: loc.begin: 275 27, loc.end: 275 29
tex_section_end: loc.begin: 275 29, loc.end: 280 3
tex_end: loc.begin: 275 29, loc.end: 280 3
middle_begin: loc.begin: 275 29, loc.end: 280 3
macro_begin: name: "o", params: {}, loc.begin: 280 3, loc.end: 281 3, text: "o "
macro_end: loc.begin: 280 3, loc.end: 281 3
macro_begin: name: "oo", params: {}, loc.begin: 281 3, loc.end: 282 3, text: "oo "
macro_end: loc.begin: 281 3, loc.end: 282 3
macro_begin: name: "ooo", params: {}, loc.begin: 282 3, loc.end: 283 3, text: "ooo "
macro_end: loc.begin: 282 3, loc.end: 283 3
macro_begin: name: "oooo", params: {}, loc.begin: 283 3, loc.end: 285 3, text: "oooo "
macro_end: loc.begin: 283 3, loc.end: 285 3
middle_end: loc.begin: 283 3, loc.end: 285 3
c_begin: loc.begin: 283 3, loc.end: 285 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 285 3, loc.end: 286 14, text: "
long mems; "
comment_begin: type: "c", loc.begin: 285 3, loc.end: 286 14
free_text: type: "tex", loc.begin: 286 14, loc.end: 286 57, text: " the number of memory references counted "
comment_end: type: "c", loc.begin: 286 14, loc.end: 286 57
free_text: type: "c", loc.begin: 286 57, loc.end: 288 3, text: "

@ "
named_section_end: loc.begin: 286 57, loc.end: 288 3
c_end: loc.begin: 286 57, loc.end: 288 3
tex_begin: loc.begin: 286 57, loc.end: 288 3
tex_section_begin: type: "unstarred", loc.begin: 286 57, loc.end: 288 3
free_text: type: "tex", loc.begin: 288 3, loc.end: 292 63, text: "Examples of these mem-counting conventions appear throughout the
program that follows. Some people will undoubtedly ask why the insertion of
macros by hand is being recommended here, when it would be possible to
develop a fancy system that counts mems automatically. The author
believes that it is best to rely on programmers to introduce "
inner_c_begin: loc.begin: 288 3, loc.end: 292 63
free_text: type: "c", loc.begin: 292 63, loc.end: 292 65, text: "o"
inner_c_end: loc.begin: 292 63, loc.end: 292 65
free_text: type: "tex", loc.begin: 292 65, loc.end: 293 2, text: " and
"
inner_c_begin: loc.begin: 292 65, loc.end: 293 2
free_text: type: "c", loc.begin: 293 2, loc.end: 293 5, text: "oo"
inner_c_end: loc.begin: 293 2, loc.end: 293 5
free_text: type: "tex", loc.begin: 293 5, loc.end: 300 54, text: ", etc., by themselves, for several reasons. (1)~The macros can be
inserted easily and quickly using a text editor. (2)~An implementation
need not pay for mems that could be avoided by a suitable optimizing
compiler or by making the \CEE/ program text slightly more complex;
thus, authors can use their good judgment to keep programs more
readable than if the code were overly hand-optimized. (3)~The
programmer should be able to see exactly where mems are being charged,
as an aid to bottleneck elimination. Occurrences of "
inner_c_begin: loc.begin: 293 5, loc.end: 300 54
free_text: type: "c", loc.begin: 300 54, loc.end: 300 56, text: "o"
inner_c_end: loc.begin: 300 54, loc.end: 300 56
free_text: type: "tex", loc.begin: 300 56, loc.end: 300 62, text: " and "
inner_c_begin: loc.begin: 300 56, loc.end: 300 62
free_text: type: "c", loc.begin: 300 62, loc.end: 300 65, text: "oo"
inner_c_end: loc.begin: 300 62, loc.end: 300 65
index_entry: entry: "discussion of \\{mems}", loc.begin: 300 65, loc.end: 305 27
free_text: type: "tex", loc.begin: 305 27, loc.end: 335 23, text: "

Computer architecture is converging rapidly these days to the
design of machines in which the exact running time of a program
depends on complicated interactions between pipelined circuitry and
the dynamic properties of cache mapping in a memory hierarchy,
not to mention the effects of compilers and operating systems.
But a good approximation to running time is usually obtained if we
assume that the amount of computation is proportional to the activity
of the memory bus between registers and main memory. This
approximation is likely to get even better in the future, as
RISC computers get faster and faster in comparison to memory devices.
Although the mem measure is far from perfect, it appears to be
significantly less distorted than any other measurement that can
be obtained without considerably more work. An implementation that
is designed to use few mems will almost certainly be efficient
on today's sequential computers, as well as on the sequential computers
we can expect to be built in the foreseeable future. And the converse
statement is even more true: An algorithm that runs fast will not
consume many mems.

Of course authors are expected to be reasonable and fair when they
are competing for minimum-mem prizes. They must be ready to
submit their programs to inspection by impartial judges. A good
algorithm will not need to abuse the spirit of realistic mem-counting.

Mems can be analyzed theoretically as well as empirically.
This means we can attach constants to estimates of running time, instead of
always resorting to $O$~notation.

@*"
tex_section_end: loc.begin: 305 27, loc.end: 335 23
tex_end: loc.begin: 305 27, loc.end: 335 23
tex_begin: loc.begin: 305 27, loc.end: 335 23
tex_section_begin: type: "starred", title: "Kruskal's algorithm.", loc.begin: 305 27, loc.end: 335 23
free_text: type: "tex", loc.begin: 335 23, loc.end: 344 5, text: "
The first algorithm we shall implement and instrument is the simplest:
It considers the edges one by one in order of nondecreasing length,
selecting each edge that does not form a cycle with previously
selected edges.

We know that the edge lengths are less than $2^{12}$, so we can sort them
into order with two passes of a $2^6$-bucket radix sort.
We will arrange to have them appear in the buckets as linked lists
of "
inner_c_begin: loc.begin: 335 23, loc.end: 344 5
free_text: type: "c", loc.begin: 344 5, loc.end: 344 9, text: "Arc"
inner_c_end: loc.begin: 344 5, loc.end: 344 9
free_text: type: "tex", loc.begin: 344 9, loc.end: 344 49, text: " records; the two utility fields of an "
inner_c_begin: loc.begin: 344 9, loc.end: 344 49
free_text: type: "c", loc.begin: 344 49, loc.end: 344 53, text: "Arc"
inner_c_end: loc.begin: 344 49, loc.end: 344 53
free_text: type: "tex", loc.begin: 344 53, loc.end: 345 2, text: " will be called
"
inner_c_begin: loc.begin: 344 53, loc.end: 345 2
free_text: type: "c", loc.begin: 345 2, loc.end: 345 7, text: "from"
inner_c_end: loc.begin: 345 2, loc.end: 345 7
free_text: type: "tex", loc.begin: 345 7, loc.end: 345 13, text: " and "
inner_c_begin: loc.begin: 345 7, loc.end: 345 13
free_text: type: "c", loc.begin: 345 13, loc.end: 345 19, text: "klink"
inner_c_end: loc.begin: 345 13, loc.end: 345 19
tex_section_end: loc.begin: 345 19, loc.end: 347 3
tex_end: loc.begin: 345 19, loc.end: 347 3
middle_begin: loc.begin: 345 19, loc.end: 347 3
macro_begin: name: "from", params: {}, loc.begin: 347 3, loc.end: 348 3, text: "from "
macro_end: loc.begin: 347 3, loc.end: 348 3
macro_begin: name: "klink", params: {}, loc.begin: 348 3, loc.end: 350 3, text: "klink "
macro_end: loc.begin: 348 3, loc.end: 350 3
middle_end: loc.begin: 348 3, loc.end: 350 3
c_begin: loc.begin: 348 3, loc.end: 350 3
named_section_begin: name: "Put all the edges into |bucket[0]| through |bucket[63]|", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 350 3, loc.end: 356 24, text: "
o,n=g->n;
for (l=0;l<64;l++) oo,aucket[l]=bucket[l]=NULL;
for (o,v=g->vertices;v<g->vertices+n;v++)
  for (o,a=v->arcs;a&&(o,a->tip>v);o,a=a->next) {
    o,a->from=v;
    o,l=a->len&0x3f; "
comment_begin: type: "c", loc.begin: 350 3, loc.end: 356 24
free_text: type: "tex", loc.begin: 356 24, loc.end: 356 41, text: " length mod 64 "
comment_end: type: "c", loc.begin: 356 24, loc.end: 356 41
c_format: code: "@+"
free_text: type: "c", loc.begin: 361 29, loc.end: 364 24, text: "register long ll;
    register Arc *aa=a;
    o,a=a->klink;
    o,ll=aa->len>>6; "
comment_begin: type: "c", loc.begin: 361 29, loc.end: 364 24
free_text: type: "tex", loc.begin: 364 24, loc.end: 364 48, text: " length divided by 64 "
comment_end: type: "c", loc.begin: 364 24, loc.end: 364 48
free_text: type: "c", loc.begin: 364 48, loc.end: 369 3, text: "
    oo,aa->klink=bucket[ll];
    o,bucket[ll]=aa;
  }

@ "
named_section_end: loc.begin: 364 48, loc.end: 369 3
c_end: loc.begin: 364 48, loc.end: 369 3
tex_begin: loc.begin: 364 48, loc.end: 369 3
tex_section_begin: type: "unstarred", loc.begin: 364 48, loc.end: 369 3
tex_section_end: loc.begin: 369 3, loc.end: 369 5
tex_end: loc.begin: 369 3, loc.end: 369 5
c_begin: loc.begin: 369 3, loc.end: 369 5
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 369 5, loc.end: 370 33, text: "
Arc *aucket[64], *bucket[64]; "
comment_begin: type: "c", loc.begin: 369 5, loc.end: 370 33
free_text: type: "tex", loc.begin: 370 33, loc.end: 370 66, text: " heads of linked lists of arcs "
comment_end: type: "c", loc.begin: 370 33, loc.end: 370 66
free_text: type: "c", loc.begin: 370 66, loc.end: 372 3, text: "

@ "
named_section_end: loc.begin: 370 66, loc.end: 372 3
c_end: loc.begin: 370 66, loc.end: 372 3
tex_begin: loc.begin: 370 66, loc.end: 372 3
tex_section_begin: type: "unstarred", loc.begin: 370 66, loc.end: 372 3
tex_section_end: loc.begin: 372 3, loc.end: 374 3
tex_end: loc.begin: 372 3, loc.end: 374 3
c_begin: loc.begin: 372 3, loc.end: 374 3
named_section_begin: name: "Sub...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
section_name: name: "Local variables for |krusk|", isPrefix: loc.begin: 377 4, loc.end: 377 6, false
c_format: code: "@;"
c_format: code: "@#"
section_name: name: "Put all the edges...", isPrefix: loc.begin: 377 10, loc.end: 379 5, true
free_text: type: "c", loc.begin: 379 5, loc.end: 380 24, text: ";
  if (verbose) printf("
string_begin: type: "c", loc.begin: 379 5, loc.end: 380 24
free_text: type: "tex", loc.begin: 380 24, loc.end: 380 71, text: "   [%ld mems to sort the edges into buckets]\n"
string_end: type: "c", loc.begin: 380 24, loc.end: 380 71
section_name: name: "Put all the vertices into components by themselves", isPrefix: loc.begin: 380 71, loc.end: 381 5, false
section_name: name: "If |u| and |v| are already in the same component, |continue|", isPrefix: loc.begin: 381 5, loc.end: 386 9, false
section_name: name: "Merge the components containing |u| and |v|", isPrefix: loc.begin: 386 9, loc.end: 390 9, false
free_text: type: "c", loc.begin: 390 9, loc.end: 392 22, text: ";
    }
  return INFINITY; "
comment_begin: type: "c", loc.begin: 390 9, loc.end: 392 22
free_text: type: "tex", loc.begin: 392 22, loc.end: 392 52, text: " the graph wasn't connected "
comment_end: type: "c", loc.begin: 392 22, loc.end: 392 52
free_text: type: "c", loc.begin: 392 52, loc.end: 395 3, text: "
}

@ "
named_section_end: loc.begin: 392 52, loc.end: 395 3
c_end: loc.begin: 392 52, loc.end: 395 3
tex_begin: loc.begin: 392 52, loc.end: 395 3
tex_section_begin: type: "unstarred", loc.begin: 392 52, loc.end: 395 3
tex_section_end: loc.begin: 395 3, loc.end: 398 3
tex_end: loc.begin: 395 3, loc.end: 398 3
c_begin: loc.begin: 395 3, loc.end: 398 3
named_section_begin: name: "Local variables for |krusk|", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 398 3, loc.end: 399 20, text: "
register Arc *a; "
comment_begin: type: "c", loc.begin: 398 3, loc.end: 399 20
free_text: type: "tex", loc.begin: 399 20, loc.end: 399 48, text: " current edge of interest "
comment_end: type: "c", loc.begin: 399 20, loc.end: 399 48
free_text: type: "c", loc.begin: 399 48, loc.end: 400 20, text: "
register long l; "
comment_begin: type: "c", loc.begin: 399 48, loc.end: 400 20
free_text: type: "tex", loc.begin: 400 20, loc.end: 400 50, text: " current bucket of interest "
comment_end: type: "c", loc.begin: 400 20, loc.end: 400 50
free_text: type: "c", loc.begin: 400 50, loc.end: 401 29, text: "
register Vertex *u,*v,*w; "
comment_begin: type: "c", loc.begin: 400 50, loc.end: 401 29
free_text: type: "tex", loc.begin: 401 29, loc.end: 401 61, text: " current vertices of interest "
comment_end: type: "c", loc.begin: 401 29, loc.end: 401 61
free_text: type: "c", loc.begin: 401 61, loc.end: 402 28, text: "
unsigned long tot_len=0; "
comment_begin: type: "c", loc.begin: 401 61, loc.end: 402 28
free_text: type: "tex", loc.begin: 402 28, loc.end: 402 68, text: " total length of edges already chosen "
comment_end: type: "c", loc.begin: 402 28, loc.end: 402 68
free_text: type: "c", loc.begin: 402 68, loc.end: 403 11, text: "
long n; "
comment_begin: type: "c", loc.begin: 402 68, loc.end: 403 11
free_text: type: "tex", loc.begin: 403 11, loc.end: 403 37, text: " the number of vertices "
comment_end: type: "c", loc.begin: 403 11, loc.end: 403 37
free_text: type: "c", loc.begin: 403 37, loc.end: 406 3, text: "
long components;

@ "
named_section_end: loc.begin: 403 37, loc.end: 406 3
c_end: loc.begin: 403 37, loc.end: 406 3
tex_begin: loc.begin: 403 37, loc.end: 406 3
tex_section_begin: type: "unstarred", loc.begin: 403 37, loc.end: 406 3
free_text: type: "tex", loc.begin: 406 3, loc.end: 406 30, text: "The remaining things that "
inner_c_begin: loc.begin: 406 3, loc.end: 406 30
free_text: type: "c", loc.begin: 406 30, loc.end: 406 36, text: "krusk"
inner_c_end: loc.begin: 406 30, loc.end: 406 36
index_entry: entry: "Knuth, Donald Ervin", loc.begin: 406 36, loc.end: 410 24
index_entry: entry: "Sch\"onhage, Arnold", loc.begin: 410 24, loc.end: 411 24
free_text: type: "tex", loc.begin: 411 24, loc.end: 415 58, text: "
in {\sl Theoretical Computer Science\/ \bf 6} (1978), 281--315.

The vertices of each component (that is, of each connected fragment defined by
the edges selected so far) will be linked circularly by "
inner_c_begin: loc.begin: 411 24, loc.end: 415 58
free_text: type: "c", loc.begin: 415 58, loc.end: 415 64, text: "clink"
inner_c_end: loc.begin: 415 58, loc.end: 415 64
free_text: type: "tex", loc.begin: 415 64, loc.end: 416 25, text: " pointers.
Each vertex also has a "
inner_c_begin: loc.begin: 415 64, loc.end: 416 25
free_text: type: "c", loc.begin: 416 25, loc.end: 416 30, text: "comp"
inner_c_end: loc.begin: 416 25, loc.end: 416 30
free_text: type: "tex", loc.begin: 416 30, loc.end: 418 4, text: " field that points to a unique vertex
representing its component. Each component representative also has
a "
inner_c_begin: loc.begin: 416 30, loc.end: 418 4
free_text: type: "c", loc.begin: 418 4, loc.end: 418 10, text: "csize"
inner_c_end: loc.begin: 418 4, loc.end: 418 10
tex_section_end: loc.begin: 418 10, loc.end: 420 3
tex_end: loc.begin: 418 10, loc.end: 420 3
middle_begin: loc.begin: 418 10, loc.end: 420 3
macro_begin: name: "clink", params: {}, loc.begin: 420 3, loc.end: 421 3, text: "clink "
macro_end: loc.begin: 420 3, loc.end: 421 3
macro_begin: name: "comp", params: {}, loc.begin: 421 3, loc.end: 422 3, text: "comp "
macro_end: loc.begin: 421 3, loc.end: 422 3
macro_begin: name: "csize", params: {}, loc.begin: 422 3, loc.end: 424 3, text: "csize "
macro_end: loc.begin: 422 3, loc.end: 424 3
middle_end: loc.begin: 422 3, loc.end: 424 3
c_begin: loc.begin: 422 3, loc.end: 424 3
named_section_begin: name: "If |u| and |v| are already in the same component, |continue|", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 424 3, loc.end: 427 3, text: "
if (oo,u->comp==v->comp) continue;

@ "
named_section_end: loc.begin: 424 3, loc.end: 427 3
c_end: loc.begin: 424 3, loc.end: 427 3
tex_begin: loc.begin: 424 3, loc.end: 427 3
tex_section_begin: type: "unstarred", loc.begin: 424 3, loc.end: 427 3
free_text: type: "tex", loc.begin: 427 3, loc.end: 427 50, text: "We don't need to charge any mems for fetching "
inner_c_begin: loc.begin: 427 3, loc.end: 427 50
free_text: type: "c", loc.begin: 427 50, loc.end: 427 62, text: "g->vertices"
inner_c_end: loc.begin: 427 50, loc.end: 427 62
free_text: type: "tex", loc.begin: 427 62, loc.end: 428 2, text: ", because
"
inner_c_begin: loc.begin: 427 62, loc.end: 428 2
free_text: type: "c", loc.begin: 428 2, loc.end: 428 8, text: "krusk"
inner_c_end: loc.begin: 428 2, loc.end: 428 8
index_entry: entry: "discussion of \\{mems}", loc.begin: 428 8, loc.end: 429 27
tex_section_end: loc.begin: 429 27, loc.end: 431 3
tex_end: loc.begin: 429 27, loc.end: 431 3
c_begin: loc.begin: 429 27, loc.end: 431 3
named_section_begin: name: "Put all the vertices...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 431 3, loc.end: 438 3, text: "
for (v=g->vertices;v<g->vertices+n;v++) {
  oo,v->clink=v->comp=v;
  o,v->csize=1;
}
components=n;

@ "
named_section_end: loc.begin: 431 3, loc.end: 438 3
c_end: loc.begin: 431 3, loc.end: 438 3
tex_begin: loc.begin: 431 3, loc.end: 438 3
tex_section_begin: type: "unstarred", loc.begin: 431 3, loc.end: 438 3
free_text: type: "tex", loc.begin: 438 3, loc.end: 439 13, text: "The operation of merging two components together requires us to
change two "
inner_c_begin: loc.begin: 438 3, loc.end: 439 13
free_text: type: "c", loc.begin: 439 13, loc.end: 439 19, text: "clink"
inner_c_end: loc.begin: 439 13, loc.end: 439 19
free_text: type: "tex", loc.begin: 439 19, loc.end: 439 35, text: " pointers, one "
inner_c_begin: loc.begin: 439 19, loc.end: 439 35
free_text: type: "c", loc.begin: 439 35, loc.end: 439 41, text: "csize"
inner_c_end: loc.begin: 439 35, loc.end: 439 41
free_text: type: "tex", loc.begin: 439 41, loc.end: 439 58, text: " field, and the "
inner_c_begin: loc.begin: 439 41, loc.end: 439 58
free_text: type: "c", loc.begin: 439 58, loc.end: 439 63, text: "comp"
inner_c_end: loc.begin: 439 58, loc.end: 439 63
free_text: type: "tex", loc.begin: 439 63, loc.end: 442 40, text: "
fields in each vertex of the smaller component.

Here we charge two mems for the first "
inner_c_begin: loc.begin: 439 63, loc.end: 442 40
free_text: type: "c", loc.begin: 442 40, loc.end: 442 43, text: "if"
inner_c_end: loc.begin: 442 40, loc.end: 442 43
free_text: type: "tex", loc.begin: 442 43, loc.end: 442 57, text: " test, since "
inner_c_begin: loc.begin: 442 43, loc.end: 442 57
free_text: type: "c", loc.begin: 442 57, loc.end: 442 66, text: "u->csize"
inner_c_end: loc.begin: 442 57, loc.end: 442 66
free_text: type: "tex", loc.begin: 442 66, loc.end: 443 2, text: " and
"
inner_c_begin: loc.begin: 442 66, loc.end: 443 2
free_text: type: "c", loc.begin: 443 2, loc.end: 443 11, text: "v->csize"
inner_c_end: loc.begin: 443 2, loc.end: 443 11
free_text: type: "tex", loc.begin: 443 11, loc.end: 444 7, text: " are being fetched from memory. Then we charge only one mem
when "
inner_c_begin: loc.begin: 443 11, loc.end: 444 7
free_text: type: "c", loc.begin: 444 7, loc.end: 444 16, text: "u->csize"
inner_c_end: loc.begin: 444 7, loc.end: 444 16
free_text: type: "tex", loc.begin: 444 16, loc.end: 446 51, text: " is being updated, since the values being added together
have already been fetched. True, the compiler has to be smart to
realize that it's safe to add the fetched values "
inner_c_begin: loc.begin: 444 16, loc.end: 446 51
free_text: type: "c", loc.begin: 446 51, loc.end: 446 69, text: "u->csize+v->csize"
inner_c_end: loc.begin: 446 51, loc.end: 446 69
free_text: type: "tex", loc.begin: 446 69, loc.end: 447 14, text: "
even though "
inner_c_begin: loc.begin: 446 69, loc.end: 447 14
free_text: type: "c", loc.begin: 447 14, loc.end: 447 16, text: "u"
inner_c_end: loc.begin: 447 14, loc.end: 447 16
free_text: type: "tex", loc.begin: 447 16, loc.end: 447 22, text: " and "
inner_c_begin: loc.begin: 447 16, loc.end: 447 22
free_text: type: "c", loc.begin: 447 22, loc.end: 447 24, text: "v"
inner_c_end: loc.begin: 447 22, loc.end: 447 24
index_entry: entry: "discussion of \\{mems}", loc.begin: 447 24, loc.end: 452 27
tex_section_end: loc.begin: 452 27, loc.end: 454 3
tex_end: loc.begin: 452 27, loc.end: 454 3
c_begin: loc.begin: 452 27, loc.end: 454 3
named_section_begin: name: "Merge the components containing |u| and |v|", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 454 3, loc.end: 455 14, text: "
u=u->comp; "
comment_begin: type: "c", loc.begin: 454 3, loc.end: 455 14
free_text: type: "tex", loc.begin: 455 14, loc.end: 455 16, text: " "
inner_c_begin: loc.begin: 455 14, loc.end: 455 16
free_text: type: "c", loc.begin: 455 16, loc.end: 455 24, text: "u->comp"
inner_c_end: loc.begin: 455 16, loc.end: 455 24
free_text: type: "tex", loc.begin: 455 24, loc.end: 455 64, text: " has already been fetched from memory "
comment_end: type: "c", loc.begin: 455 24, loc.end: 455 64
free_text: type: "c", loc.begin: 455 64, loc.end: 456 14, text: "
v=v->comp; "
comment_begin: type: "c", loc.begin: 455 64, loc.end: 456 14
free_text: type: "tex", loc.begin: 456 14, loc.end: 456 26, text: " ditto for "
inner_c_begin: loc.begin: 456 14, loc.end: 456 26
free_text: type: "c", loc.begin: 456 26, loc.end: 456 34, text: "v->comp"
inner_c_end: loc.begin: 456 26, loc.end: 456 34
free_text: type: "tex", loc.begin: 456 34, loc.end: 456 37, text: " "
comment_end: type: "c", loc.begin: 456 34, loc.end: 456 37
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 458 15, loc.end: 459 5, text: "v=w;
} "
comment_begin: type: "c", loc.begin: 458 15, loc.end: 459 5
free_text: type: "tex", loc.begin: 459 5, loc.end: 459 11, text: " now "
inner_c_begin: loc.begin: 459 5, loc.end: 459 11
free_text: type: "c", loc.begin: 459 11, loc.end: 459 13, text: "v"
inner_c_end: loc.begin: 459 11, loc.end: 459 13
free_text: type: "tex", loc.begin: 459 13, loc.end: 459 43, text: "'s component is smaller than "
inner_c_begin: loc.begin: 459 13, loc.end: 459 43
free_text: type: "c", loc.begin: 459 43, loc.end: 459 45, text: "u"
inner_c_end: loc.begin: 459 43, loc.end: 459 45
free_text: type: "tex", loc.begin: 459 45, loc.end: 459 69, text: "'s (or equally small) "
comment_end: type: "c", loc.begin: 459 45, loc.end: 459 69
free_text: type: "c", loc.begin: 459 69, loc.end: 469 37, text: "
o,u->csize+=v->csize;
o,w=v->clink;
oo,v->clink=u->clink;
o,u->clink=w;
for (;;o,w=w->clink) {
  o,w->comp=u;
  if (w==v) break;
}
  
@*"
named_section_end: loc.begin: 459 69, loc.end: 469 37
c_end: loc.begin: 459 69, loc.end: 469 37
tex_begin: loc.begin: 459 69, loc.end: 469 37
tex_section_begin: type: "starred", title: " Jarn{\'\i}k and Prim's algorithm.", loc.begin: 459 69, loc.end: 469 37
free_text: type: "tex", loc.begin: 469 37, loc.end: 480 13, text: "
A second approach to minimum spanning trees is also pretty simple,
except for one technicality: We want to write it in a sufficiently
general manner that different priority queue algorithms can be plugged in.
The basic idea is to choose an arbitrary vertex $v_0$ and connect it to its
nearest neighbor~$v_1$, then to connect that fragment to its nearest
neighbor~$v_2$, and so on. A priority queue holds all vertices that
are adjacent to but not already in the current fragment; the key value
stored with each vertex is its distance to the current fragment.

We want the priority queue data structure to support the four
operations "
inner_c_begin: loc.begin: 469 37, loc.end: 480 13
free_text: type: "c", loc.begin: 480 13, loc.end: 480 27, text: "init_queue(d)"
inner_c_end: loc.begin: 480 13, loc.end: 480 27
free_text: type: "tex", loc.begin: 480 27, loc.end: 480 30, text: ", "
inner_c_begin: loc.begin: 480 27, loc.end: 480 30
free_text: type: "c", loc.begin: 480 30, loc.end: 480 43, text: "enqueue(v,d)"
inner_c_end: loc.begin: 480 30, loc.end: 480 43
free_text: type: "tex", loc.begin: 480 43, loc.end: 480 46, text: ", "
inner_c_begin: loc.begin: 480 43, loc.end: 480 46
free_text: type: "c", loc.begin: 480 46, loc.end: 480 59, text: "requeue(v,d)"
inner_c_end: loc.begin: 480 46, loc.end: 480 59
free_text: type: "tex", loc.begin: 480 59, loc.end: 481 2, text: ", and
"
inner_c_begin: loc.begin: 480 59, loc.end: 481 2
free_text: type: "c", loc.begin: 481 2, loc.end: 481 12, text: "del_min()"
inner_c_end: loc.begin: 481 2, loc.end: 481 12
index_entry: entry: "Dijkstra, Edsger Wybe", loc.begin: 481 12, loc.end: 485 26
tex_section_end: loc.begin: 485 26, loc.end: 491 3
tex_end: loc.begin: 485 26, loc.end: 491 3
middle_begin: loc.begin: 485 26, loc.end: 491 3
macro_begin: name: "dist", params: {}, loc.begin: 491 3, loc.end: 492 3, text: "dist "
macro_end: loc.begin: 491 3, loc.end: 492 3
macro_begin: name: "backlink", params: {}, loc.begin: 492 3, loc.end: 494 3, text: "backlink "
macro_end: loc.begin: 492 3, loc.end: 494 3
middle_end: loc.begin: 492 3, loc.end: 494 3
c_begin: loc.begin: 492 3, loc.end: 494 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 495 10, loc.end: 495 30, text: " (*init_queue)(); "
comment_begin: type: "c", loc.begin: 495 10, loc.end: 495 30
free_text: type: "tex", loc.begin: 495 30, loc.end: 495 64, text: " create an empty priority queue "
comment_end: type: "c", loc.begin: 495 30, loc.end: 495 64
free_text: type: "c", loc.begin: 496 10, loc.end: 496 27, text: " (*enqueue)(); "
comment_begin: type: "c", loc.begin: 496 10, loc.end: 496 27
free_text: type: "tex", loc.begin: 496 27, loc.end: 496 73, text: " insert a new element in the priority queue "
comment_end: type: "c", loc.begin: 496 27, loc.end: 496 73
free_text: type: "c", loc.begin: 497 10, loc.end: 497 27, text: " (*requeue)(); "
comment_begin: type: "c", loc.begin: 497 10, loc.end: 497 27
free_text: type: "tex", loc.begin: 497 27, loc.end: 497 74, text: " decrease the key of an element in the queue "
comment_end: type: "c", loc.begin: 497 27, loc.end: 497 74
free_text: type: "c", loc.begin: 497 74, loc.end: 498 25, text: "
Vertex *(*del_min)(); "
comment_begin: type: "c", loc.begin: 497 74, loc.end: 498 25
free_text: type: "tex", loc.begin: 498 25, loc.end: 498 64, text: " remove an element with smallest key "
comment_end: type: "c", loc.begin: 498 25, loc.end: 498 64
free_text: type: "c", loc.begin: 498 64, loc.end: 500 3, text: "

@ "
named_section_end: loc.begin: 498 64, loc.end: 500 3
c_end: loc.begin: 498 64, loc.end: 500 3
tex_begin: loc.begin: 498 64, loc.end: 500 3
tex_section_begin: type: "unstarred", loc.begin: 498 64, loc.end: 500 3
free_text: type: "tex", loc.begin: 500 3, loc.end: 503 40, text: "The vertices in this algorithm are initially ``unseen''; they become
``seen'' when they enter the priority queue, and finally ``known''
when they leave it and enter the current fragment.
We will put a special constant in the "
inner_c_begin: loc.begin: 500 3, loc.end: 503 40
free_text: type: "c", loc.begin: 503 40, loc.end: 503 49, text: "backlink"
inner_c_end: loc.begin: 503 40, loc.end: 503 49
free_text: type: "tex", loc.begin: 503 49, loc.end: 505 2, text: " field
of known vertices. A vertex will be unseen if and only if its
"
inner_c_begin: loc.begin: 503 49, loc.end: 505 2
free_text: type: "c", loc.begin: 505 2, loc.end: 505 11, text: "backlink"
inner_c_end: loc.begin: 505 2, loc.end: 505 11
free_text: type: "tex", loc.begin: 505 11, loc.end: 505 16, text: " is~"
inner_c_begin: loc.begin: 505 11, loc.end: 505 16
free_text: type: "c", loc.begin: 505 16, loc.end: 505 21, text: "NULL"
inner_c_end: loc.begin: 505 16, loc.end: 505 21
tex_section_end: loc.begin: 505 21, loc.end: 507 3
tex_end: loc.begin: 505 21, loc.end: 507 3
middle_begin: loc.begin: 505 21, loc.end: 507 3
macro_begin: name: "KNOWN", params: {}, loc.begin: 507 3, loc.end: 509 3, text: "KNOWN "
macro_end: loc.begin: 507 3, loc.end: 509 3
middle_end: loc.begin: 507 3, loc.end: 509 3
c_begin: loc.begin: 507 3, loc.end: 509 3
named_section_begin: name: "Sub...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 512 4, loc.end: 512 26, text: "register Vertex *t; "
comment_begin: type: "c", loc.begin: 512 4, loc.end: 512 26
free_text: type: "tex", loc.begin: 512 26, loc.end: 512 64, text: " vertex that is just becoming known "
comment_end: type: "c", loc.begin: 512 26, loc.end: 512 64
free_text: type: "c", loc.begin: 512 64, loc.end: 513 25, text: "
  long fragment_size; "
comment_begin: type: "c", loc.begin: 512 64, loc.end: 513 25
free_text: type: "tex", loc.begin: 513 25, loc.end: 513 66, text: " number of vertices in the tree so far "
comment_end: type: "c", loc.begin: 513 25, loc.end: 513 66
free_text: type: "c", loc.begin: 513 66, loc.end: 514 30, text: "
  unsigned long tot_len=0; "
comment_begin: type: "c", loc.begin: 513 66, loc.end: 514 30
free_text: type: "tex", loc.begin: 514 30, loc.end: 514 72, text: " sum of edge lengths in the tree so far "
comment_end: type: "c", loc.begin: 514 30, loc.end: 514 72
section_name: name: "Make |t=g->vertices| the only vertex seen; also make it known", isPrefix: loc.begin: 514 72, loc.end: 516 5, false
section_name: name: "Put all unseen vertices adjacent to |t| into the queue,
      and update the distances of the other vertices adjacent to~|t|", isPrefix: loc.begin: 516 5, loc.end: 518 7, false
free_text: type: "c", loc.begin: 518 7, loc.end: 520 37, text: ";
    t=(*del_min)();
    if (t==NULL) return INFINITY; "
comment_begin: type: "c", loc.begin: 518 7, loc.end: 520 37
free_text: type: "tex", loc.begin: 520 37, loc.end: 520 66, text: " the graph is disconnected "
comment_end: type: "c", loc.begin: 520 37, loc.end: 520 66
free_text: type: "c", loc.begin: 520 66, loc.end: 529 3, text: "
    if (verbose) report(t->backlink,t,t->dist);
    o,tot_len+=t->dist;
    o,t->backlink=KNOWN;
    fragment_size++;
  }
  return tot_len;
}

@ "
named_section_end: loc.begin: 520 66, loc.end: 529 3
c_end: loc.begin: 520 66, loc.end: 529 3
tex_begin: loc.begin: 520 66, loc.end: 529 3
tex_section_begin: type: "unstarred", loc.begin: 520 66, loc.end: 529 3
free_text: type: "tex", loc.begin: 529 3, loc.end: 530 5, text: "Notice that we don't charge any mems for the subroutine call
to "
inner_c_begin: loc.begin: 529 3, loc.end: 530 5
free_text: type: "c", loc.begin: 530 5, loc.end: 530 16, text: "init_queue"
inner_c_end: loc.begin: 530 5, loc.end: 530 16
index_entry: entry: "discussion of \\{mems}", loc.begin: 530 16, loc.end: 540 27
tex_section_end: loc.begin: 540 27, loc.end: 542 3
tex_end: loc.begin: 540 27, loc.end: 542 3
c_begin: loc.begin: 540 27, loc.end: 542 3
named_section_begin: name: "Make |t=g->vertices| the only vertex seen; also make it known", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 542 3, loc.end: 546 22, text: "
for (oo,t=g->vertices+g->n-1;t>g->vertices;t--) o,t->backlink=NULL;
o,t->backlink=KNOWN;
fragment_size=1;
(*init_queue)(0L); "
comment_begin: type: "c", loc.begin: 542 3, loc.end: 546 22
free_text: type: "tex", loc.begin: 546 22, loc.end: 546 55, text: " make the priority queue empty "
comment_end: type: "c", loc.begin: 546 22, loc.end: 546 55
free_text: type: "c", loc.begin: 546 55, loc.end: 548 3, text: "

@ "
named_section_end: loc.begin: 546 55, loc.end: 548 3
c_end: loc.begin: 546 55, loc.end: 548 3
tex_begin: loc.begin: 546 55, loc.end: 548 3
tex_section_begin: type: "unstarred", loc.begin: 546 55, loc.end: 548 3
tex_section_end: loc.begin: 548 3, loc.end: 548 5
tex_end: loc.begin: 548 3, loc.end: 548 5
c_begin: loc.begin: 548 3, loc.end: 548 5
named_section_begin: name: "Put all unseen vertices adjacent to |t| into the queue,
      and update the distances of the other vertices adjacent to~|t|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 549 4, loc.end: 549 23, text: "register Arc *a; "
comment_begin: type: "c", loc.begin: 549 4, loc.end: 549 23
free_text: type: "tex", loc.begin: 549 23, loc.end: 549 45, text: " an arc leading from "
inner_c_begin: loc.begin: 549 23, loc.end: 549 45
free_text: type: "c", loc.begin: 549 45, loc.end: 549 47, text: "t"
inner_c_end: loc.begin: 549 45, loc.end: 549 47
free_text: type: "tex", loc.begin: 549 47, loc.end: 549 50, text: " "
comment_end: type: "c", loc.begin: 549 47, loc.end: 549 50
free_text: type: "c", loc.begin: 549 50, loc.end: 551 27, text: "
  for (o,a=t->arcs; a; o,a=a->next) {
    register Vertex *v; "
comment_begin: type: "c", loc.begin: 549 50, loc.end: 551 27
free_text: type: "tex", loc.begin: 551 27, loc.end: 551 50, text: " a vertex adjacent to "
inner_c_begin: loc.begin: 551 27, loc.end: 551 50
free_text: type: "c", loc.begin: 551 50, loc.end: 551 52, text: "t"
inner_c_end: loc.begin: 551 50, loc.end: 551 52
free_text: type: "tex", loc.begin: 551 52, loc.end: 551 55, text: " "
comment_end: type: "c", loc.begin: 551 52, loc.end: 551 55
free_text: type: "c", loc.begin: 551 55, loc.end: 553 28, text: "
    o,v=a->tip;
    if (o,v->backlink) { "
comment_begin: type: "c", loc.begin: 551 55, loc.end: 553 28
free_text: type: "tex", loc.begin: 553 28, loc.end: 553 30, text: " "
inner_c_begin: loc.begin: 553 28, loc.end: 553 30
free_text: type: "c", loc.begin: 553 30, loc.end: 553 32, text: "v"
inner_c_end: loc.begin: 553 30, loc.end: 553 32
free_text: type: "tex", loc.begin: 553 32, loc.end: 553 57, text: " has already been seen "
comment_end: type: "c", loc.begin: 553 32, loc.end: 553 57
free_text: type: "c", loc.begin: 553 57, loc.end: 557 35, text: "
      if (v->backlink>KNOWN) {
        if (oo,a->len<v->dist) {
          o,v->backlink=t;
          (*requeue)(v,a->len); "
comment_begin: type: "c", loc.begin: 553 57, loc.end: 557 35
free_text: type: "tex", loc.begin: 557 35, loc.end: 557 73, text: " we found a better way to get there "
comment_end: type: "c", loc.begin: 557 35, loc.end: 557 73
c_format: code: "@+"
free_text: type: "c", loc.begin: 560 8, loc.end: 560 17, text: "else { "
comment_begin: type: "c", loc.begin: 560 8, loc.end: 560 17
free_text: type: "tex", loc.begin: 560 17, loc.end: 560 19, text: " "
inner_c_begin: loc.begin: 560 17, loc.end: 560 19
free_text: type: "c", loc.begin: 560 19, loc.end: 560 21, text: "v"
inner_c_end: loc.begin: 560 19, loc.end: 560 21
free_text: type: "tex", loc.begin: 560 21, loc.end: 560 48, text: " hasn't been seen before "
comment_end: type: "c", loc.begin: 560 21, loc.end: 560 48
free_text: type: "c", loc.begin: 560 48, loc.end: 567 16, text: "
      o,v->backlink=t;
      o,(*enqueue)(v,a->len);
    }
  }
}

@*"
named_section_end: loc.begin: 560 48, loc.end: 567 16
c_end: loc.begin: 560 48, loc.end: 567 16
tex_begin: loc.begin: 560 48, loc.end: 567 16
tex_section_begin: type: "starred", title: "Binary heaps.", loc.begin: 560 48, loc.end: 567 16
free_text: type: "tex", loc.begin: 567 16, loc.end: 568 18, text: "
To complete the "
inner_c_begin: loc.begin: 567 16, loc.end: 568 18
free_text: type: "c", loc.begin: 568 18, loc.end: 568 25, text: "jar_pr"
inner_c_end: loc.begin: 568 18, loc.end: 568 25
index_entry: entry: "Kerschenbaum, A.", loc.begin: 568 25, loc.end: 574 21
index_entry: entry: "Van Slyke, Richard Maurice", loc.begin: 574 21, loc.end: 575 31
index_entry: entry: "Williams, John William Joseph", loc.begin: 575 31, loc.end: 577 34
free_text: type: "tex", loc.begin: 577 34, loc.end: 582 2, text: "
in 1964) is presented here.

A binary heap is an array of $n$ elements, and we need space for it.
Fortunately the space is already there; we can use utility field
"
inner_c_begin: loc.begin: 577 34, loc.end: 582 2
free_text: type: "c", loc.begin: 582 2, loc.end: 582 4, text: "u"
inner_c_end: loc.begin: 582 2, loc.end: 582 4
free_text: type: "tex", loc.begin: 582 4, loc.end: 583 2, text: " in each of the vertex records of the graph. Moreover, if
"
inner_c_begin: loc.begin: 582 4, loc.end: 583 2
free_text: type: "c", loc.begin: 583 2, loc.end: 583 14, text: "heap_elt(i)"
inner_c_end: loc.begin: 583 2, loc.end: 583 14
free_text: type: "tex", loc.begin: 583 14, loc.end: 583 33, text: " points to vertex~"
inner_c_begin: loc.begin: 583 14, loc.end: 583 33
free_text: type: "c", loc.begin: 583 33, loc.end: 583 35, text: "v"
inner_c_end: loc.begin: 583 33, loc.end: 583 35
free_text: type: "tex", loc.begin: 583 35, loc.end: 584 2, text: ", we will arrange things so that
"
inner_c_begin: loc.begin: 583 35, loc.end: 584 2
free_text: type: "c", loc.begin: 584 2, loc.end: 584 18, text: "v->heap_index=i"
inner_c_end: loc.begin: 584 2, loc.end: 584 18
tex_section_end: loc.begin: 584 18, loc.end: 586 3
tex_end: loc.begin: 584 18, loc.end: 586 3
middle_begin: loc.begin: 584 18, loc.end: 586 3
macro_begin: name: "heap_elt", params: {i}, loc.begin: 586 3, loc.end: 587 3, text: "heap_elt(i)"
macro_end: loc.begin: 586 3, loc.end: 587 3
macro_begin: name: "heap_index", params: {}, loc.begin: 587 3, loc.end: 590 3, text: "heap_index "
macro_end: loc.begin: 587 3, loc.end: 590 3
middle_end: loc.begin: 587 3, loc.end: 590 3
c_begin: loc.begin: 587 3, loc.end: 590 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 590 3, loc.end: 591 15, text: "
Vertex *gv; "
comment_begin: type: "c", loc.begin: 590 3, loc.end: 591 15
free_text: type: "tex", loc.begin: 591 15, loc.end: 591 17, text: " "
inner_c_begin: loc.begin: 591 15, loc.end: 591 17
free_text: type: "c", loc.begin: 591 17, loc.end: 591 29, text: "g->vertices"
inner_c_end: loc.begin: 591 17, loc.end: 591 29
free_text: type: "tex", loc.begin: 591 29, loc.end: 591 60, text: ", the base of the heap array "
comment_end: type: "c", loc.begin: 591 29, loc.end: 591 60
free_text: type: "c", loc.begin: 591 60, loc.end: 592 15, text: "
long hsize; "
comment_begin: type: "c", loc.begin: 591 60, loc.end: 592 15
free_text: type: "tex", loc.begin: 592 15, loc.end: 592 63, text: " the number of elements currently in the heap "
comment_end: type: "c", loc.begin: 592 15, loc.end: 592 63
free_text: type: "c", loc.begin: 592 63, loc.end: 594 3, text: "

@ "
named_section_end: loc.begin: 592 63, loc.end: 594 3
c_end: loc.begin: 592 63, loc.end: 594 3
tex_begin: loc.begin: 592 63, loc.end: 594 3
tex_section_begin: type: "unstarred", loc.begin: 592 63, loc.end: 594 3
index_entry: entry: "discussion of \\{mems}", loc.begin: 594 3, loc.end: 598 27
free_text: type: "tex", loc.begin: 598 27, loc.end: 600 61, text: "

Important Note: This routine refers to the global variable "
inner_c_begin: loc.begin: 598 27, loc.end: 600 61
free_text: type: "c", loc.begin: 600 61, loc.end: 600 63, text: "g"
inner_c_end: loc.begin: 600 61, loc.end: 600 63
free_text: type: "tex", loc.begin: 600 63, loc.end: 601 9, text: ", which is
set in "
inner_c_begin: loc.begin: 600 63, loc.end: 601 9
free_text: type: "c", loc.begin: 601 9, loc.end: 601 14, text: "main"
inner_c_end: loc.begin: 601 9, loc.end: 601 14
free_text: type: "tex", loc.begin: 601 14, loc.end: 601 24, text: " (not in "
inner_c_begin: loc.begin: 601 14, loc.end: 601 24
free_text: type: "c", loc.begin: 601 24, loc.end: 601 31, text: "jar_pr"
inner_c_end: loc.begin: 601 24, loc.end: 601 31
tex_section_end: loc.begin: 601 31, loc.end: 604 3
tex_end: loc.begin: 601 31, loc.end: 604 3
c_begin: loc.begin: 601 31, loc.end: 604 3
named_section_begin: name: "Priority queue subroutines", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 604 3, loc.end: 605 21, text: "
void init_heap(d) "
comment_begin: type: "c", loc.begin: 604 3, loc.end: 605 21
free_text: type: "tex", loc.begin: 605 21, loc.end: 605 45, text: " makes the heap empty "
comment_end: type: "c", loc.begin: 605 21, loc.end: 605 45
free_text: type: "c", loc.begin: 605 45, loc.end: 612 3, text: "
  long d;
{
  gv=g->vertices;
  hsize=0;
}

@ "
named_section_end: loc.begin: 605 45, loc.end: 612 3
c_end: loc.begin: 605 45, loc.end: 612 3
tex_begin: loc.begin: 605 45, loc.end: 612 3
tex_section_begin: type: "unstarred", loc.begin: 605 45, loc.end: 612 3
free_text: type: "tex", loc.begin: 612 3, loc.end: 613 10, text: "The key invariant property that makes heaps work is
$$\hbox{"
inner_c_begin: loc.begin: 612 3, loc.end: 613 10
free_text: type: "c", loc.begin: 613 10, loc.end: 613 49, text: "heap_elt(k/2)->dist<=heap_elt(k)->dist"
inner_c_end: loc.begin: 613 10, loc.end: 613 49
free_text: type: "tex", loc.begin: 613 49, loc.end: 613 63, text: ", \qquad for "
inner_c_begin: loc.begin: 613 49, loc.end: 613 63
free_text: type: "c", loc.begin: 613 63, loc.end: 613 74, text: "1<k<=hsize"
inner_c_end: loc.begin: 613 63, loc.end: 613 74
tex_section_end: loc.begin: 613 74, loc.end: 618 3
tex_end: loc.begin: 613 74, loc.end: 618 3
c_begin: loc.begin: 613 74, loc.end: 618 3
named_section_begin: name: "Priority queue subroutines", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 618 3, loc.end: 620 16, text: "
void enq_heap(v,d)
  Vertex *v; "
comment_begin: type: "c", loc.begin: 618 3, loc.end: 620 16
free_text: type: "tex", loc.begin: 620 16, loc.end: 620 53, text: " vertex that is entering the queue "
comment_end: type: "c", loc.begin: 620 16, loc.end: 620 53
free_text: type: "c", loc.begin: 620 53, loc.end: 621 13, text: "
  long d; "
comment_begin: type: "c", loc.begin: 620 53, loc.end: 621 13
free_text: type: "tex", loc.begin: 621 13, loc.end: 621 28, text: " its key (aka "
inner_c_begin: loc.begin: 621 13, loc.end: 621 28
free_text: type: "c", loc.begin: 621 28, loc.end: 621 33, text: "dist"
inner_c_end: loc.begin: 621 28, loc.end: 621 33
free_text: type: "tex", loc.begin: 621 33, loc.end: 621 37, text: ") "
comment_end: type: "c", loc.begin: 621 33, loc.end: 621 37
c_format: code: "@+"
free_text: type: "c", loc.begin: 622 4, loc.end: 622 32, text: "register unsigned long k; "
comment_begin: type: "c", loc.begin: 622 4, loc.end: 622 32
free_text: type: "tex", loc.begin: 622 32, loc.end: 622 70, text: " position of a ``hole'' in the heap "
comment_end: type: "c", loc.begin: 622 32, loc.end: 622 70
free_text: type: "c", loc.begin: 622 70, loc.end: 623 31, text: "
  register unsigned long j; "
comment_begin: type: "c", loc.begin: 622 70, loc.end: 623 31
free_text: type: "tex", loc.begin: 623 31, loc.end: 623 62, text: " the parent of that position "
comment_end: type: "c", loc.begin: 623 31, loc.end: 623 62
free_text: type: "c", loc.begin: 623 62, loc.end: 624 25, text: "
  register Vertex *u; "
comment_begin: type: "c", loc.begin: 623 62, loc.end: 624 25
free_text: type: "tex", loc.begin: 624 25, loc.end: 624 27, text: " "
inner_c_begin: loc.begin: 624 25, loc.end: 624 27
free_text: type: "c", loc.begin: 624 27, loc.end: 624 39, text: "heap_elt(j)"
inner_c_end: loc.begin: 624 27, loc.end: 624 39
free_text: type: "tex", loc.begin: 624 39, loc.end: 624 42, text: " "
comment_end: type: "c", loc.begin: 624 39, loc.end: 624 42
free_text: type: "c", loc.begin: 624 42, loc.end: 627 13, text: "
  o,v->dist=d;
  k=++hsize;
  j=k>>1; "
comment_begin: type: "c", loc.begin: 624 42, loc.end: 627 13
free_text: type: "tex", loc.begin: 627 13, loc.end: 627 15, text: " "
inner_c_begin: loc.begin: 627 13, loc.end: 627 15
free_text: type: "c", loc.begin: 627 15, loc.end: 627 19, text: "k/2"
inner_c_end: loc.begin: 627 15, loc.end: 627 19
free_text: type: "tex", loc.begin: 627 19, loc.end: 627 22, text: " "
comment_end: type: "c", loc.begin: 627 19, loc.end: 627 22
free_text: type: "c", loc.begin: 627 22, loc.end: 629 24, text: "
  while (j>0 && (oo,(u=heap_elt(j))->dist>d)) {
    o,heap_elt(k)=u; "
comment_begin: type: "c", loc.begin: 627 22, loc.end: 629 24
free_text: type: "tex", loc.begin: 629 24, loc.end: 629 61, text: " the hole moves to parent position "
comment_end: type: "c", loc.begin: 629 24, loc.end: 629 61
free_text: type: "c", loc.begin: 629 61, loc.end: 638 3, text: "
    o,u->heap_index=k;
    k=j;
    j=k>>1;
  }
  o,heap_elt(k)=v;
  o,v->heap_index=k;
}

@ "
named_section_end: loc.begin: 629 61, loc.end: 638 3
c_end: loc.begin: 629 61, loc.end: 638 3
tex_begin: loc.begin: 629 61, loc.end: 638 3
tex_section_begin: type: "unstarred", loc.begin: 629 61, loc.end: 638 3
tex_section_end: loc.begin: 638 3, loc.end: 645 3
tex_end: loc.begin: 638 3, loc.end: 645 3
c_begin: loc.begin: 638 3, loc.end: 645 3
named_section_begin: name: "Priority queue subroutines", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 645 3, loc.end: 647 16, text: "
void req_heap(v,d)
  Vertex *v; "
comment_begin: type: "c", loc.begin: 645 3, loc.end: 647 16
free_text: type: "tex", loc.begin: 647 16, loc.end: 647 53, text: " vertex whose key is being reduced "
comment_end: type: "c", loc.begin: 647 16, loc.end: 647 53
free_text: type: "c", loc.begin: 647 53, loc.end: 648 13, text: "
  long d; "
comment_begin: type: "c", loc.begin: 647 53, loc.end: 648 13
free_text: type: "tex", loc.begin: 648 13, loc.end: 648 23, text: " its new "
inner_c_begin: loc.begin: 648 13, loc.end: 648 23
free_text: type: "c", loc.begin: 648 23, loc.end: 648 28, text: "dist"
inner_c_end: loc.begin: 648 23, loc.end: 648 28
free_text: type: "tex", loc.begin: 648 28, loc.end: 648 31, text: " "
comment_end: type: "c", loc.begin: 648 28, loc.end: 648 31
c_format: code: "@+"
free_text: type: "c", loc.begin: 649 4, loc.end: 649 32, text: "register unsigned long k; "
comment_begin: type: "c", loc.begin: 649 4, loc.end: 649 32
free_text: type: "tex", loc.begin: 649 32, loc.end: 649 70, text: " position of a ``hole'' in the heap "
comment_end: type: "c", loc.begin: 649 32, loc.end: 649 70
free_text: type: "c", loc.begin: 649 70, loc.end: 650 31, text: "
  register unsigned long j; "
comment_begin: type: "c", loc.begin: 649 70, loc.end: 650 31
free_text: type: "tex", loc.begin: 650 31, loc.end: 650 62, text: " the parent of that position "
comment_end: type: "c", loc.begin: 650 31, loc.end: 650 62
free_text: type: "c", loc.begin: 650 62, loc.end: 651 25, text: "
  register Vertex *u; "
comment_begin: type: "c", loc.begin: 650 62, loc.end: 651 25
free_text: type: "tex", loc.begin: 651 25, loc.end: 651 27, text: " "
inner_c_begin: loc.begin: 651 25, loc.end: 651 27
free_text: type: "c", loc.begin: 651 27, loc.end: 651 39, text: "heap_elt(j)"
inner_c_end: loc.begin: 651 27, loc.end: 651 39
free_text: type: "tex", loc.begin: 651 39, loc.end: 651 42, text: " "
comment_end: type: "c", loc.begin: 651 39, loc.end: 651 42
free_text: type: "c", loc.begin: 651 42, loc.end: 653 24, text: "
  o,v->dist=d;
  o,k=v->heap_index; "
comment_begin: type: "c", loc.begin: 651 42, loc.end: 653 24
free_text: type: "tex", loc.begin: 653 24, loc.end: 653 30, text: " now "
inner_c_begin: loc.begin: 653 24, loc.end: 653 30
free_text: type: "c", loc.begin: 653 30, loc.end: 653 44, text: "heap_elt(k)=v"
inner_c_end: loc.begin: 653 30, loc.end: 653 44
free_text: type: "tex", loc.begin: 653 44, loc.end: 653 47, text: " "
comment_end: type: "c", loc.begin: 653 44, loc.end: 653 47
free_text: type: "c", loc.begin: 653 47, loc.end: 654 13, text: "
  j=k>>1; "
comment_begin: type: "c", loc.begin: 653 47, loc.end: 654 13
free_text: type: "tex", loc.begin: 654 13, loc.end: 654 15, text: " "
inner_c_begin: loc.begin: 654 13, loc.end: 654 15
free_text: type: "c", loc.begin: 654 15, loc.end: 654 19, text: "k/2"
inner_c_end: loc.begin: 654 15, loc.end: 654 19
free_text: type: "tex", loc.begin: 654 19, loc.end: 654 22, text: " "
comment_end: type: "c", loc.begin: 654 19, loc.end: 654 22
free_text: type: "c", loc.begin: 654 22, loc.end: 655 48, text: "
  if (j>0 && (oo,(u=heap_elt(j))->dist>d)) { "
comment_begin: type: "c", loc.begin: 654 22, loc.end: 655 48
free_text: type: "tex", loc.begin: 655 48, loc.end: 655 68, text: " change is needed "
comment_end: type: "c", loc.begin: 655 48, loc.end: 655 68
c_format: code: "@+"
free_text: type: "c", loc.begin: 656 9, loc.end: 657 26, text: "{
      o,heap_elt(k)=u; "
comment_begin: type: "c", loc.begin: 656 9, loc.end: 657 26
free_text: type: "tex", loc.begin: 657 26, loc.end: 657 63, text: " the hole moves to parent position "
comment_end: type: "c", loc.begin: 657 26, loc.end: 657 63
free_text: type: "c", loc.begin: 657 63, loc.end: 660 17, text: "
      o,u->heap_index=k;
      k=j;
      j=k>>1; "
comment_begin: type: "c", loc.begin: 657 63, loc.end: 660 17
free_text: type: "tex", loc.begin: 660 17, loc.end: 660 19, text: " "
inner_c_begin: loc.begin: 660 17, loc.end: 660 19
free_text: type: "c", loc.begin: 660 19, loc.end: 660 23, text: "k/2"
inner_c_end: loc.begin: 660 19, loc.end: 660 23
free_text: type: "tex", loc.begin: 660 23, loc.end: 660 26, text: " "
comment_end: type: "c", loc.begin: 660 23, loc.end: 660 26
c_format: code: "@+"
free_text: type: "c", loc.begin: 661 8, loc.end: 667 3, text: "while (j>0 && (oo,(u=heap_elt(j))->dist>d));
    o,heap_elt(k)=v;
    o,v->heap_index=k;
  }
}

@ "
named_section_end: loc.begin: 661 8, loc.end: 667 3
c_end: loc.begin: 661 8, loc.end: 667 3
tex_begin: loc.begin: 661 8, loc.end: 667 3
tex_section_begin: type: "unstarred", loc.begin: 661 8, loc.end: 667 3
free_text: type: "tex", loc.begin: 667 3, loc.end: 669 2, text: "Finally, the procedure for removing the vertex with smallest key is
only a bit more difficult. The vertex to be removed is always
"
inner_c_begin: loc.begin: 667 3, loc.end: 669 2
free_text: type: "c", loc.begin: 669 2, loc.end: 669 14, text: "heap_elt(1)"
inner_c_end: loc.begin: 669 2, loc.end: 669 14
free_text: type: "tex", loc.begin: 669 14, loc.end: 669 54, text: ". After we delete it, we ``sift down'' "
inner_c_begin: loc.begin: 669 14, loc.end: 669 54
free_text: type: "c", loc.begin: 669 54, loc.end: 669 70, text: "heap_elt(hsize)"
inner_c_end: loc.begin: 669 54, loc.end: 669 70
free_text: type: "tex", loc.begin: 669 70, loc.end: 672 46, text: ",
until the basic heap inequalities hold once again.

At a crucial point in this process, we have "
inner_c_begin: loc.begin: 669 70, loc.end: 672 46
free_text: type: "c", loc.begin: 672 46, loc.end: 672 62, text: "j->dist<u->dist"
inner_c_end: loc.begin: 672 46, loc.end: 672 62
free_text: type: "tex", loc.begin: 672 62, loc.end: 674 2, text: ". We cannot
then have
"
inner_c_begin: loc.begin: 672 62, loc.end: 674 2
free_text: type: "c", loc.begin: 674 2, loc.end: 674 12, text: "j=hsize+1"
inner_c_end: loc.begin: 674 2, loc.end: 674 12
free_text: type: "tex", loc.begin: 674 12, loc.end: 674 52, text: ", because the previous steps have made "
inner_c_begin: loc.begin: 674 12, loc.end: 674 52
free_text: type: "c", loc.begin: 674 52, loc.end: 674 78, text: "(hsize+1)->dist=u->dist=d"
inner_c_end: loc.begin: 674 52, loc.end: 674 78
tex_section_end: loc.begin: 674 78, loc.end: 676 3
tex_end: loc.begin: 674 78, loc.end: 676 3
c_begin: loc.begin: 674 78, loc.end: 676 3
named_section_begin: name: "Prior...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 678 4, loc.end: 678 17, text: "Vertex *v; "
comment_begin: type: "c", loc.begin: 678 4, loc.end: 678 17
free_text: type: "tex", loc.begin: 678 17, loc.end: 678 37, text: " vertex to return "
comment_end: type: "c", loc.begin: 678 17, loc.end: 678 37
free_text: type: "c", loc.begin: 678 37, loc.end: 679 25, text: "
  register Vertex *u; "
comment_begin: type: "c", loc.begin: 678 37, loc.end: 679 25
free_text: type: "tex", loc.begin: 679 25, loc.end: 679 53, text: " vertex being sifted down "
comment_end: type: "c", loc.begin: 679 25, loc.end: 679 53
free_text: type: "c", loc.begin: 679 53, loc.end: 680 31, text: "
  register unsigned long k; "
comment_begin: type: "c", loc.begin: 679 53, loc.end: 680 31
free_text: type: "tex", loc.begin: 680 31, loc.end: 680 51, text: " hole in the heap "
comment_end: type: "c", loc.begin: 680 31, loc.end: 680 51
free_text: type: "c", loc.begin: 680 51, loc.end: 681 31, text: "
  register unsigned long j; "
comment_begin: type: "c", loc.begin: 680 51, loc.end: 681 31
free_text: type: "tex", loc.begin: 681 31, loc.end: 681 53, text: " child of that hole "
comment_end: type: "c", loc.begin: 681 31, loc.end: 681 53
free_text: type: "c", loc.begin: 681 53, loc.end: 682 22, text: "
  register long d; "
comment_begin: type: "c", loc.begin: 681 53, loc.end: 682 22
free_text: type: "tex", loc.begin: 682 22, loc.end: 682 24, text: " "
inner_c_begin: loc.begin: 682 22, loc.end: 682 24
free_text: type: "c", loc.begin: 682 24, loc.end: 682 32, text: "u->dist"
inner_c_end: loc.begin: 682 24, loc.end: 682 32
free_text: type: "tex", loc.begin: 682 32, loc.end: 682 71, text: ", the key of the vertex being sifted "
comment_end: type: "c", loc.begin: 682 32, loc.end: 682 71
free_text: type: "c", loc.begin: 682 71, loc.end: 692 34, text: "
  if (hsize==0) return NULL;
  o,v=heap_elt(1);
  o,u=heap_elt(hsize--);
  o,d=u->dist;
  k=1;
  j=2;
  while (j<=hsize) {
    if (oooo,heap_elt(j)->dist>heap_elt(j+1)->dist) j++;
    if (heap_elt(j)->dist>=d) break;
    o,heap_elt(k)=heap_elt(j); "
comment_begin: type: "c", loc.begin: 682 71, loc.end: 692 34
free_text: type: "tex", loc.begin: 692 34, loc.end: 692 55, text: " NB: we cannot have "
inner_c_begin: loc.begin: 692 34, loc.end: 692 55
free_text: type: "c", loc.begin: 692 55, loc.end: 692 63, text: "j>hsize"
inner_c_end: loc.begin: 692 55, loc.end: 692 63
free_text: type: "tex", loc.begin: 692 63, loc.end: 692 77, text: ", see above "
comment_end: type: "c", loc.begin: 692 63, loc.end: 692 77
free_text: type: "c", loc.begin: 692 77, loc.end: 694 12, text: "
    o,heap_elt(k)->heap_index=k;
    k=j; "
comment_begin: type: "c", loc.begin: 692 77, loc.end: 694 12
free_text: type: "tex", loc.begin: 694 12, loc.end: 694 48, text: " the hole moves to child position "
comment_end: type: "c", loc.begin: 694 12, loc.end: 694 48
free_text: type: "c", loc.begin: 694 48, loc.end: 695 15, text: "
    j=k<<1; "
comment_begin: type: "c", loc.begin: 694 48, loc.end: 695 15
free_text: type: "tex", loc.begin: 695 15, loc.end: 695 17, text: " "
inner_c_begin: loc.begin: 695 15, loc.end: 695 17
free_text: type: "c", loc.begin: 695 17, loc.end: 695 20, text: "2k"
inner_c_end: loc.begin: 695 17, loc.end: 695 20
free_text: type: "tex", loc.begin: 695 20, loc.end: 695 23, text: " "
comment_end: type: "c", loc.begin: 695 20, loc.end: 695 23
free_text: type: "c", loc.begin: 695 23, loc.end: 702 3, text: "
  }
  o,heap_elt(k)=u;
  o,u->heap_index=k;
  return v;
}

@ "
named_section_end: loc.begin: 695 23, loc.end: 702 3
c_end: loc.begin: 695 23, loc.end: 702 3
tex_begin: loc.begin: 695 23, loc.end: 702 3
tex_section_begin: type: "unstarred", loc.begin: 695 23, loc.end: 702 3
tex_section_end: loc.begin: 702 3, loc.end: 704 3
tex_end: loc.begin: 702 3, loc.end: 704 3
c_begin: loc.begin: 702 3, loc.end: 704 3
named_section_begin: name: "Execute |jar_pr(g)| with binary heaps as the priority queue algorithm", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 704 3, loc.end: 710 11, text: "
init_queue=init_heap;
enqueue=enq_heap;
requeue=req_heap;
del_min=del_heap;
if (sp_length!=jar_pr(g)) {
  printf("
string_begin: type: "c", loc.begin: 704 3, loc.end: 710 11
free_text: type: "tex", loc.begin: 710 11, loc.end: 710 58, text: " ...oops, I've got a bug, please fix fix fix\n"
string_end: type: "c", loc.begin: 710 11, loc.end: 710 58
free_text: type: "c", loc.begin: 710 58, loc.end: 714 19, text: ");
  return -4;
}

@*"
named_section_end: loc.begin: 710 58, loc.end: 714 19
c_end: loc.begin: 710 58, loc.end: 714 19
tex_begin: loc.begin: 710 58, loc.end: 714 19
tex_section_begin: type: "starred", title: "Fibonacci heaps.", loc.begin: 710 58, loc.end: 714 19
index_entry: entry: "Fibonacci, Leonardo, heaps", loc.begin: 714 19, loc.end: 721 31
index_entry: entry: "Fredman, Michael Lawrence", loc.begin: 721 31, loc.end: 722 30
index_entry: entry: "Tarjan, Robert Endre", loc.begin: 722 30, loc.end: 723 25
free_text: type: "tex", loc.begin: 723 25, loc.end: 763 3, text: "
to do better than this. The Jarn{\'\i}k/Prim algorithm does $O(n)$
enqueueing operations, $O(n)$ delete-min operations, and $O(m)$
requeueing operations; so Fredman and Tarjan designed a data structure
that would support requeueing in ``constant amortized time.'' In other
words, Fibonacci heaps allow us to do $m$ requeueing operations with a
total cost of~$O(m)$, even though some of the individual requeueings
might take longer. The resulting asymptotic running time is then
$O(m+n\log n)$. (This turns out to be optimum within a constant
factor, when the same technique is applied to Dijkstra's algorithm for
shortest paths. But for minimum spanning trees the Fibonacci method is
not always optimum; for example, if $m\approx n\sqrt{\mathstrut\log n}$, the
algorithm of Cheriton and Tarjan has slightly better asymptotic
behavior, $O(m\log\log n)$.)

Fibonacci heaps are more complex than binary heaps, so we can expect
that overhead  costs will make them non-competitive unless $m$ and $n$ are
quite large. Furthermore, it is not clear that the running time with simple
binary heaps will behave as $m\log n$ on realistic data, because
$O(m\log n)$ is a worst-case estimate based on rather pessimistic
assumptions. (For example, requeueing might rarely require many
iterations of the siftup loop.) But it will be instructive to
implement Fibonacci heaps as best we can, just to see how good they
look in actual practice.

Let us say that the {\sl rank\/} of a node in a forest is the number
of children it has. A Fibonacci heap is an unordered forest of trees
in which the key of each node is less than or equal to the key of each
child of that node, and in which the following further condition,
called property~F, also holds: The ranks $\{r_1,r_2,\ldots,r_k\}$ of the
children of every node of rank~$k$, when put into nondecreasing
order $r_1\le r_2\le\cdots\le r_k$, satisfy $r_j\ge j-2$ for all~$j$.

As a consequence of property F, we can prove by induction that every
node of rank~$k$ has at least $F_{k+2}$ descendants (including itself).
Therefore, for example, we cannot have a node of rank $\ge30$ unless
the total size of the forest is at least $F_{32}=2{,}178{,}309$. We cannot
have a node of rank $\ge46$ unless the total size of the forest
exceeds~$2^{32}$.

@ "
tex_section_end: loc.begin: 723 25, loc.end: 763 3
tex_end: loc.begin: 723 25, loc.end: 763 3
tex_begin: loc.begin: 723 25, loc.end: 763 3
tex_section_begin: type: "unstarred", loc.begin: 723 25, loc.end: 763 3
free_text: type: "tex", loc.begin: 763 3, loc.end: 765 37, text: "We will represent a Fibonacci heap with a rather elaborate data structure,
in order to guarantee the efficiency of all the necessary operations.
Each node will have four pointers: "
inner_c_begin: loc.begin: 763 3, loc.end: 765 37
free_text: type: "c", loc.begin: 765 37, loc.end: 765 44, text: "parent"
inner_c_end: loc.begin: 765 37, loc.end: 765 44
free_text: type: "tex", loc.begin: 765 44, loc.end: 766 2, text: ", the node's parent (or
"
inner_c_begin: loc.begin: 765 44, loc.end: 766 2
free_text: type: "c", loc.begin: 766 2, loc.end: 766 7, text: "NULL"
inner_c_end: loc.begin: 766 2, loc.end: 766 7
free_text: type: "tex", loc.begin: 766 7, loc.end: 766 33, text: " if the node is a root); "
inner_c_begin: loc.begin: 766 7, loc.end: 766 33
free_text: type: "c", loc.begin: 766 33, loc.end: 766 39, text: "child"
inner_c_end: loc.begin: 766 33, loc.end: 766 39
free_text: type: "tex", loc.begin: 766 39, loc.end: 767 46, text: ", one of the node's children
(or undefined if the node has no children); "
inner_c_begin: loc.begin: 766 39, loc.end: 767 46
free_text: type: "c", loc.begin: 767 46, loc.end: 767 51, text: "lsib"
inner_c_end: loc.begin: 767 46, loc.end: 767 51
free_text: type: "tex", loc.begin: 767 51, loc.end: 767 57, text: " and "
inner_c_begin: loc.begin: 767 51, loc.end: 767 57
free_text: type: "c", loc.begin: 767 57, loc.end: 767 62, text: "rsib"
inner_c_end: loc.begin: 767 57, loc.end: 767 62
free_text: type: "tex", loc.begin: 767 62, loc.end: 769 44, text: ", the
node's left and right siblings. The children of each node, and the
roots of the forest, are doubly linked by "
inner_c_begin: loc.begin: 767 62, loc.end: 769 44
free_text: type: "c", loc.begin: 769 44, loc.end: 769 49, text: "lsib"
inner_c_end: loc.begin: 769 44, loc.end: 769 49
free_text: type: "tex", loc.begin: 769 49, loc.end: 769 55, text: " and "
inner_c_begin: loc.begin: 769 49, loc.end: 769 55
free_text: type: "c", loc.begin: 769 55, loc.end: 769 60, text: "rsib"
inner_c_end: loc.begin: 769 55, loc.end: 769 60
free_text: type: "tex", loc.begin: 769 60, loc.end: 771 17, text: " in
circular lists; the nodes in these lists can appear in any convenient
order, and the "
inner_c_begin: loc.begin: 769 60, loc.end: 771 17
free_text: type: "c", loc.begin: 771 17, loc.end: 771 23, text: "child"
inner_c_end: loc.begin: 771 17, loc.end: 771 23
free_text: type: "tex", loc.begin: 771 23, loc.end: 788 38, text: " pointer can point to any child.

Besides the four pointers, there is a \\{rank} field, which tells how
many children exist, and a \\{tag} field, which is either 0 or~1.

Suppose a node has children of ranks $\{r_1,r_2,\ldots,r_k\}$, where
$r_1\le r_2\le\cdots\le r_k$. We know that $r_j\ge j-2$ for all~$j$;
we say that the node has $l$ {\sl critical\/} children if there are
$l$ cases of equality, where $r_j=j-2$. Our implementation will
guarantee that any node with $l$ critical children will have at
least $l$ tagged children of the corresponding ranks. For example,
suppose a node has seven children, of respective ranks $\{1,1,1,2,4,4,6\}$.
Then it has three critical children, because $r_3=1$, $r_4=2$, and
$r_6=4$. In our implementation, at least one of the children of
rank~1 will have $\\{tag}=1$, and so will the child of rank~2; so will
one of the children of rank~4.

There is an external pointer called "
inner_c_begin: loc.begin: 771 23, loc.end: 788 38
free_text: type: "c", loc.begin: 788 38, loc.end: 788 45, text: "F_heap"
inner_c_end: loc.begin: 788 38, loc.end: 788 45
free_text: type: "tex", loc.begin: 788 45, loc.end: 789 48, text: ", which indicates a node
whose key is smallest. (If the heap is empty, "
inner_c_begin: loc.begin: 788 45, loc.end: 789 48
free_text: type: "c", loc.begin: 789 48, loc.end: 789 55, text: "F_heap"
inner_c_end: loc.begin: 789 48, loc.end: 789 55
free_text: type: "tex", loc.begin: 789 55, loc.end: 789 60, text: " is~"
inner_c_begin: loc.begin: 789 55, loc.end: 789 60
free_text: type: "c", loc.begin: 789 60, loc.end: 789 65, text: "NULL"
inner_c_end: loc.begin: 789 60, loc.end: 789 65
tex_section_end: loc.begin: 789 65, loc.end: 791 3
tex_end: loc.begin: 789 65, loc.end: 791 3
c_begin: loc.begin: 789 65, loc.end: 791 3
named_section_begin: name: "Prior...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 794 18, loc.end: 796 3, text: "}

@ "
named_section_end: loc.begin: 794 18, loc.end: 796 3
c_end: loc.begin: 794 18, loc.end: 796 3
tex_begin: loc.begin: 794 18, loc.end: 796 3
tex_section_begin: type: "unstarred", loc.begin: 794 18, loc.end: 796 3
tex_section_end: loc.begin: 796 3, loc.end: 796 5
tex_end: loc.begin: 796 3, loc.end: 796 5
c_begin: loc.begin: 796 3, loc.end: 796 5
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 796 5, loc.end: 797 19, text: "
Vertex *F_heap; "
comment_begin: type: "c", loc.begin: 796 5, loc.end: 797 19
free_text: type: "tex", loc.begin: 797 19, loc.end: 797 56, text: " pointer to the ring of root nodes "
comment_end: type: "c", loc.begin: 797 19, loc.end: 797 56
free_text: type: "c", loc.begin: 797 56, loc.end: 799 3, text: "

@ "
named_section_end: loc.begin: 797 56, loc.end: 799 3
c_end: loc.begin: 797 56, loc.end: 799 3
tex_begin: loc.begin: 797 56, loc.end: 799 3
tex_section_begin: type: "unstarred", loc.begin: 797 56, loc.end: 799 3
free_text: type: "tex", loc.begin: 799 3, loc.end: 800 23, text: "We can save a bit of space and time by combining the \\{rank} and \\{tag}
fields into a single "
inner_c_begin: loc.begin: 799 3, loc.end: 800 23
free_text: type: "c", loc.begin: 800 23, loc.end: 800 32, text: "rank_tag"
inner_c_end: loc.begin: 800 23, loc.end: 800 32
free_text: type: "tex", loc.begin: 800 32, loc.end: 803 6, text: " field, which contains $\\{rank}*2+\\{tag}$.

Vertices in GraphBase graphs have six utility fields. That's just enough
for "
inner_c_begin: loc.begin: 800 32, loc.end: 803 6
free_text: type: "c", loc.begin: 803 6, loc.end: 803 13, text: "parent"
inner_c_end: loc.begin: 803 6, loc.end: 803 13
free_text: type: "tex", loc.begin: 803 13, loc.end: 803 16, text: ", "
inner_c_begin: loc.begin: 803 13, loc.end: 803 16
free_text: type: "c", loc.begin: 803 16, loc.end: 803 22, text: "child"
inner_c_end: loc.begin: 803 16, loc.end: 803 22
free_text: type: "tex", loc.begin: 803 22, loc.end: 803 25, text: ", "
inner_c_begin: loc.begin: 803 22, loc.end: 803 25
free_text: type: "c", loc.begin: 803 25, loc.end: 803 30, text: "lsib"
inner_c_end: loc.begin: 803 25, loc.end: 803 30
free_text: type: "tex", loc.begin: 803 30, loc.end: 803 33, text: ", "
inner_c_begin: loc.begin: 803 30, loc.end: 803 33
free_text: type: "c", loc.begin: 803 33, loc.end: 803 38, text: "rsib"
inner_c_end: loc.begin: 803 33, loc.end: 803 38
free_text: type: "tex", loc.begin: 803 38, loc.end: 803 41, text: ", "
inner_c_begin: loc.begin: 803 38, loc.end: 803 41
free_text: type: "c", loc.begin: 803 41, loc.end: 803 50, text: "rank_tag"
inner_c_end: loc.begin: 803 41, loc.end: 803 50
free_text: type: "tex", loc.begin: 803 50, loc.end: 804 2, text: ", and the key field
"
inner_c_begin: loc.begin: 803 50, loc.end: 804 2
free_text: type: "c", loc.begin: 804 2, loc.end: 804 7, text: "dist"
inner_c_end: loc.begin: 804 2, loc.end: 804 7
free_text: type: "tex", loc.begin: 804 7, loc.end: 804 45, text: ". But unfortunately we also need the "
inner_c_begin: loc.begin: 804 7, loc.end: 804 45
free_text: type: "c", loc.begin: 804 45, loc.end: 804 54, text: "backlink"
inner_c_end: loc.begin: 804 45, loc.end: 804 54
free_text: type: "tex", loc.begin: 804 54, loc.end: 809 30, text: " field, so
we are over the limit. That's not really so bad, however; we
can set up another array of $n$ records, and point to it. The
extra running time needed for indirect pointing does not have to
be charged to mems, because a production system involving Fibonacci
heaps would simply redefine "
inner_c_begin: loc.begin: 804 54, loc.end: 809 30
free_text: type: "c", loc.begin: 809 30, loc.end: 809 37, text: "Vertex"
inner_c_end: loc.begin: 809 30, loc.end: 809 37
index_entry: entry: "discussion of \\{mems}", loc.begin: 809 37, loc.end: 812 27
free_text: type: "tex", loc.begin: 812 27, loc.end: 814 18, text: "

We will want an "
inner_c_begin: loc.begin: 812 27, loc.end: 814 18
free_text: type: "c", loc.begin: 814 18, loc.end: 814 22, text: "Arc"
inner_c_end: loc.begin: 814 18, loc.end: 814 22
tex_section_end: loc.begin: 814 22, loc.end: 818 3
tex_end: loc.begin: 814 22, loc.end: 818 3
middle_begin: loc.begin: 814 22, loc.end: 818 3
macro_begin: name: "newarc", params: {}, loc.begin: 818 3, loc.end: 819 3, text: "newarc "
macro_end: loc.begin: 818 3, loc.end: 819 3
macro_begin: name: "parent", params: {}, loc.begin: 819 3, loc.end: 820 3, text: "parent "
macro_end: loc.begin: 819 3, loc.end: 820 3
macro_begin: name: "child", params: {}, loc.begin: 820 3, loc.end: 821 3, text: "child "
macro_end: loc.begin: 820 3, loc.end: 821 3
macro_begin: name: "lsib", params: {}, loc.begin: 821 3, loc.end: 822 3, text: "lsib "
macro_end: loc.begin: 821 3, loc.end: 822 3
macro_begin: name: "rsib", params: {}, loc.begin: 822 3, loc.end: 823 3, text: "rsib "
macro_end: loc.begin: 822 3, loc.end: 823 3
macro_begin: name: "rank_tag", params: {}, loc.begin: 823 3, loc.end: 825 3, text: "rank_tag "
macro_end: loc.begin: 823 3, loc.end: 825 3
middle_end: loc.begin: 823 3, loc.end: 825 3
c_begin: loc.begin: 823 3, loc.end: 825 3
named_section_begin: name: "Allocate additional space needed by the more complex algorithms...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 826 4, loc.end: 830 13, text: "register Arc *aa;
  register Vertex *uu;
  aa=gb_typed_alloc(g->n,Arc,g->aux_data);
  if (aa==NULL) {
    printf("
string_begin: type: "c", loc.begin: 826 4, loc.end: 830 13
free_text: type: "tex", loc.begin: 830 13, loc.end: 830 73, text: " and there isn't enough space to try the other methods.\n\n"
string_end: type: "c", loc.begin: 830 13, loc.end: 830 73
free_text: type: "c", loc.begin: 830 73, loc.end: 837 3, text: ");
    goto done;
  }
  for (uu=g->vertices;uu<g->vertices+g->n;uu++,aa++)
    uu->newarc=aa;
}

@ "
named_section_end: loc.begin: 830 73, loc.end: 837 3
c_end: loc.begin: 830 73, loc.end: 837 3
tex_begin: loc.begin: 830 73, loc.end: 837 3
tex_section_begin: type: "unstarred", loc.begin: 830 73, loc.end: 837 3
free_text: type: "tex", loc.begin: 837 3, loc.end: 851 21, text: "The {\sl potential energy\/} of a Fibonacci heap, as we are
representing it, is defined to be the number of trees in the forest
plus twice the total number of tagged children. When we operate on a
heap, we will store potential energy to be used up later; then it will
be possible to do the later operations with only a small incremental
cost to the running time. (Potential energy is just a way to prove
that the amortized cost is small; it does not appear explicitly in our
implementation. It simply explains why the number of mems we compute
will always be $O(m+n\log n)$.)

Enqueueing is easy: We simply insert the new element as a new tree in
the forest. This costs a constant amount of time, including the cost of
one new unit of potential energy for the new tree.

We can assume that "
inner_c_begin: loc.begin: 837 3, loc.end: 851 21
free_text: type: "c", loc.begin: 851 21, loc.end: 851 34, text: "F_heap->dist"
inner_c_end: loc.begin: 851 21, loc.end: 851 34
tex_section_end: loc.begin: 851 34, loc.end: 854 3
tex_end: loc.begin: 851 34, loc.end: 854 3
c_begin: loc.begin: 851 34, loc.end: 854 3
named_section_begin: name: "Prior...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 854 3, loc.end: 856 16, text: "
void enq_F_heap(v,d)
  Vertex *v; "
comment_begin: type: "c", loc.begin: 854 3, loc.end: 856 16
free_text: type: "tex", loc.begin: 856 16, loc.end: 856 53, text: " vertex that is entering the queue "
comment_end: type: "c", loc.begin: 856 16, loc.end: 856 53
free_text: type: "c", loc.begin: 856 53, loc.end: 857 13, text: "
  long d; "
comment_begin: type: "c", loc.begin: 856 53, loc.end: 857 13
free_text: type: "tex", loc.begin: 857 13, loc.end: 857 28, text: " its key (aka "
inner_c_begin: loc.begin: 857 13, loc.end: 857 28
free_text: type: "c", loc.begin: 857 28, loc.end: 857 33, text: "dist"
inner_c_end: loc.begin: 857 28, loc.end: 857 33
free_text: type: "tex", loc.begin: 857 33, loc.end: 857 37, text: ") "
comment_end: type: "c", loc.begin: 857 33, loc.end: 857 37
free_text: type: "c", loc.begin: 857 37, loc.end: 861 22, text: "
{
  o,v->dist=d;
  o,v->parent=NULL;
  o,v->rank_tag=0; "
comment_begin: type: "c", loc.begin: 857 37, loc.end: 861 22
free_text: type: "tex", loc.begin: 861 22, loc.end: 861 24, text: " "
inner_c_begin: loc.begin: 861 22, loc.end: 861 24
free_text: type: "c", loc.begin: 861 24, loc.end: 861 33, text: "v->child"
inner_c_end: loc.begin: 861 24, loc.end: 861 33
free_text: type: "tex", loc.begin: 861 33, loc.end: 861 52, text: " need not be set "
comment_end: type: "c", loc.begin: 861 33, loc.end: 861 52
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 864 14, loc.end: 873 3, text: "register Vertex *u;
    o,u=F_heap->lsib;
    o,v->lsib=u;
    o,v->rsib=F_heap;
    oo,F_heap->lsib=u->rsib=v;
    if (F_heap->dist>d) F_heap=v;
  }
}

@ "
named_section_end: loc.begin: 864 14, loc.end: 873 3
c_end: loc.begin: 864 14, loc.end: 873 3
tex_begin: loc.begin: 864 14, loc.end: 873 3
tex_section_begin: type: "unstarred", loc.begin: 864 14, loc.end: 873 3
free_text: type: "tex", loc.begin: 873 3, loc.end: 875 58, text: "Requeueing is of medium difficulty. If the key is being decreased in
a root node, or if the decrease doesn't make the key less than the key
of its parent, no links need to change (except possibly "
inner_c_begin: loc.begin: 873 3, loc.end: 875 58
free_text: type: "c", loc.begin: 875 58, loc.end: 875 65, text: "F_heap"
inner_c_end: loc.begin: 875 58, loc.end: 875 65
free_text: type: "tex", loc.begin: 875 65, loc.end: 880 33, text: "
itself). Otherwise we detach the node and its descendants from its
present family and put this former subtree into the forest as a new
tree. (One unit of potential energy must be stored with it.)

The rank of the former parent, "
inner_c_begin: loc.begin: 875 65, loc.end: 880 33
free_text: type: "c", loc.begin: 880 33, loc.end: 880 35, text: "p"
inner_c_end: loc.begin: 880 33, loc.end: 880 35
free_text: type: "tex", loc.begin: 880 35, loc.end: 880 57, text: ", decreases by~1. If "
inner_c_begin: loc.begin: 880 35, loc.end: 880 57
free_text: type: "c", loc.begin: 880 57, loc.end: 880 59, text: "p"
inner_c_end: loc.begin: 880 57, loc.end: 880 59
free_text: type: "tex", loc.begin: 880 59, loc.end: 881 27, text: " is a root,
we're done. Otherwise if "
inner_c_begin: loc.begin: 880 59, loc.end: 881 27
free_text: type: "c", loc.begin: 881 27, loc.end: 881 29, text: "p"
inner_c_end: loc.begin: 881 27, loc.end: 881 29
free_text: type: "tex", loc.begin: 881 29, loc.end: 883 56, text: " was not tagged, we tag it (and pay for
two additional units of energy). Property~F still holds, because an
untagged node can always admit a decrease in rank. If "
inner_c_begin: loc.begin: 881 29, loc.end: 883 56
free_text: type: "c", loc.begin: 883 56, loc.end: 883 58, text: "p"
inner_c_end: loc.begin: 883 56, loc.end: 883 58
free_text: type: "tex", loc.begin: 883 58, loc.end: 884 21, text: " was tagged,
however, we detach "
inner_c_begin: loc.begin: 883 58, loc.end: 884 21
free_text: type: "c", loc.begin: 884 21, loc.end: 884 23, text: "p"
inner_c_end: loc.begin: 884 21, loc.end: 884 23
free_text: type: "tex", loc.begin: 884 23, loc.end: 885 31, text: " and its remaining descendants, making it another
new tree of the forest, with "
inner_c_begin: loc.begin: 884 23, loc.end: 885 31
free_text: type: "c", loc.begin: 885 31, loc.end: 885 33, text: "p"
inner_c_end: loc.begin: 885 31, loc.end: 885 33
free_text: type: "tex", loc.begin: 885 33, loc.end: 886 68, text: " no longer tagged. Removing the tag
releases enough stored energy to pay for the extra work of moving~"
inner_c_begin: loc.begin: 885 33, loc.end: 886 68
free_text: type: "c", loc.begin: 886 68, loc.end: 886 70, text: "p"
inner_c_end: loc.begin: 886 68, loc.end: 886 70
free_text: type: "tex", loc.begin: 886 70, loc.end: 887 36, text: ".
Then we must decrease the rank of "
inner_c_begin: loc.begin: 886 70, loc.end: 887 36
free_text: type: "c", loc.begin: 887 36, loc.end: 887 38, text: "p"
inner_c_end: loc.begin: 887 36, loc.end: 887 38
tex_section_end: loc.begin: 887 38, loc.end: 895 3
tex_end: loc.begin: 887 38, loc.end: 895 3
c_begin: loc.begin: 887 38, loc.end: 895 3
named_section_begin: name: "Prior...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 895 3, loc.end: 897 16, text: "
void req_F_heap(v,d)
  Vertex *v; "
comment_begin: type: "c", loc.begin: 895 3, loc.end: 897 16
free_text: type: "tex", loc.begin: 897 16, loc.end: 897 53, text: " vertex whose key is being reduced "
comment_end: type: "c", loc.begin: 897 16, loc.end: 897 53
free_text: type: "c", loc.begin: 897 53, loc.end: 898 13, text: "
  long d; "
comment_begin: type: "c", loc.begin: 897 53, loc.end: 898 13
free_text: type: "tex", loc.begin: 898 13, loc.end: 898 23, text: " its new "
inner_c_begin: loc.begin: 898 13, loc.end: 898 23
free_text: type: "c", loc.begin: 898 23, loc.end: 898 28, text: "dist"
inner_c_end: loc.begin: 898 23, loc.end: 898 28
free_text: type: "tex", loc.begin: 898 28, loc.end: 898 31, text: " "
comment_end: type: "c", loc.begin: 898 28, loc.end: 898 31
c_format: code: "@+"
free_text: type: "c", loc.begin: 899 4, loc.end: 899 30, text: "register Vertex *p,*pp; "
comment_begin: type: "c", loc.begin: 899 4, loc.end: 899 30
free_text: type: "tex", loc.begin: 899 30, loc.end: 899 58, text: " parent and grandparent of "
inner_c_begin: loc.begin: 899 30, loc.end: 899 58
free_text: type: "c", loc.begin: 899 58, loc.end: 899 60, text: "v"
inner_c_end: loc.begin: 899 58, loc.end: 899 60
free_text: type: "tex", loc.begin: 899 60, loc.end: 899 63, text: " "
comment_end: type: "c", loc.begin: 899 60, loc.end: 899 63
free_text: type: "c", loc.begin: 899 63, loc.end: 900 28, text: "
  register Vertex *u,*w; "
comment_begin: type: "c", loc.begin: 899 63, loc.end: 900 28
free_text: type: "tex", loc.begin: 900 28, loc.end: 900 61, text: " other vertices being modified "
comment_end: type: "c", loc.begin: 900 28, loc.end: 900 61
free_text: type: "c", loc.begin: 900 61, loc.end: 901 22, text: "
  register long r; "
comment_begin: type: "c", loc.begin: 900 61, loc.end: 901 22
free_text: type: "tex", loc.begin: 901 22, loc.end: 901 53, text: " twice the rank plus the tag "
comment_end: type: "c", loc.begin: 901 22, loc.end: 901 53
c_format: code: "@+"
free_text: type: "c", loc.begin: 906 6, loc.end: 909 19, text: "else if (o,p->dist>d)
    while(1) {
      o,r=p->rank_tag;
      if (r>=4) "
comment_begin: type: "c", loc.begin: 906 6, loc.end: 909 19
free_text: type: "tex", loc.begin: 909 19, loc.end: 909 21, text: " "
inner_c_begin: loc.begin: 909 19, loc.end: 909 21
free_text: type: "c", loc.begin: 909 21, loc.end: 909 23, text: "v"
inner_c_end: loc.begin: 909 21, loc.end: 909 23
free_text: type: "tex", loc.begin: 909 23, loc.end: 909 47, text: " is not an only child "
comment_end: type: "c", loc.begin: 909 23, loc.end: 909 47
section_name: name: "Remove |v| from its family", isPrefix: loc.begin: 909 47, loc.end: 910 11, false
section_name: name: "Insert |v| into the forest", isPrefix: loc.begin: 910 11, loc.end: 911 9, false
free_text: type: "c", loc.begin: 911 9, loc.end: 913 25, text: ";
      o,pp=p->parent;
      if (pp==NULL) { "
comment_begin: type: "c", loc.begin: 911 9, loc.end: 913 25
free_text: type: "tex", loc.begin: 913 25, loc.end: 913 41, text: " the parent of "
inner_c_begin: loc.begin: 913 25, loc.end: 913 41
free_text: type: "c", loc.begin: 913 41, loc.end: 913 43, text: "v"
inner_c_end: loc.begin: 913 41, loc.end: 913 43
free_text: type: "tex", loc.begin: 913 43, loc.end: 913 56, text: " is a root "
comment_end: type: "c", loc.begin: 913 43, loc.end: 913 56
c_format: code: "@+"
free_text: type: "c", loc.begin: 914 29, loc.end: 916 25, text: "break;
      }
      if ((r&1)==0) { "
comment_begin: type: "c", loc.begin: 914 29, loc.end: 916 25
free_text: type: "tex", loc.begin: 916 25, loc.end: 916 41, text: " the parent of "
inner_c_begin: loc.begin: 916 25, loc.end: 916 41
free_text: type: "c", loc.begin: 916 41, loc.end: 916 43, text: "v"
inner_c_end: loc.begin: 916 41, loc.end: 916 43
free_text: type: "tex", loc.begin: 916 43, loc.end: 916 58, text: " is untagged "
comment_end: type: "c", loc.begin: 916 43, loc.end: 916 58
c_format: code: "@+"
free_text: type: "c", loc.begin: 917 29, loc.end: 917 38, text: "break; "
comment_begin: type: "c", loc.begin: 917 29, loc.end: 917 38
free_text: type: "tex", loc.begin: 917 38, loc.end: 917 57, text: " now it's tagged "
comment_end: type: "c", loc.begin: 917 38, loc.end: 917 57
c_format: code: "@+"
free_text: type: "c", loc.begin: 918 10, loc.end: 918 36, text: "else o,p->rank_tag=r-2; "
comment_begin: type: "c", loc.begin: 918 10, loc.end: 918 36
free_text: type: "tex", loc.begin: 918 36, loc.end: 918 72, text: " tagged parent will become a root "
comment_end: type: "c", loc.begin: 918 36, loc.end: 918 72
c_format: code: "@+"
free_text: type: "c", loc.begin: 919 13, loc.end: 923 3, text: "p=pp;
    }
}

@ "
named_section_end: loc.begin: 919 13, loc.end: 923 3
c_end: loc.begin: 919 13, loc.end: 923 3
tex_begin: loc.begin: 919 13, loc.end: 923 3
tex_section_begin: type: "unstarred", loc.begin: 919 13, loc.end: 923 3
tex_section_end: loc.begin: 923 3, loc.end: 923 5
tex_end: loc.begin: 923 3, loc.end: 923 5
c_begin: loc.begin: 923 3, loc.end: 923 5
named_section_begin: name: "Remove |v| from its family", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 923 5, loc.end: 932 3, text: "
{
  o,u=v->lsib;
  o,w=v->rsib;
  o,u->rsib=w;
  o,w->lsib=u;
  if (o,p->child==v) o,p->child=w;
}

@ "
named_section_end: loc.begin: 923 5, loc.end: 932 3
c_end: loc.begin: 923 5, loc.end: 932 3
tex_begin: loc.begin: 923 5, loc.end: 932 3
tex_section_begin: type: "unstarred", loc.begin: 923 5, loc.end: 932 3
tex_section_end: loc.begin: 932 3, loc.end: 932 5
tex_end: loc.begin: 932 3, loc.end: 932 5
c_begin: loc.begin: 932 3, loc.end: 932 5
named_section_begin: name: "Insert |v| into the forest", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 932 5, loc.end: 938 33, text: "
o,v->parent=NULL;
o,u=F_heap->lsib;
o,v->lsib=u;
o,v->rsib=F_heap;
oo,F_heap->lsib=u->rsib=v;
if (F_heap->dist>d) F_heap=v; "
comment_begin: type: "c", loc.begin: 932 5, loc.end: 938 33
free_text: type: "tex", loc.begin: 938 33, loc.end: 938 74, text: " this can happen only with the original "
inner_c_begin: loc.begin: 938 33, loc.end: 938 74
free_text: type: "c", loc.begin: 938 74, loc.end: 938 76, text: "v"
inner_c_end: loc.begin: 938 74, loc.end: 938 76
free_text: type: "tex", loc.begin: 938 76, loc.end: 938 79, text: " "
comment_end: type: "c", loc.begin: 938 76, loc.end: 938 79
free_text: type: "c", loc.begin: 938 79, loc.end: 940 3, text: "

@ "
named_section_end: loc.begin: 938 79, loc.end: 940 3
c_end: loc.begin: 938 79, loc.end: 940 3
tex_begin: loc.begin: 938 79, loc.end: 940 3
tex_section_begin: type: "unstarred", loc.begin: 938 79, loc.end: 940 3
free_text: type: "tex", loc.begin: 940 3, loc.end: 940 8, text: "The "
inner_c_begin: loc.begin: 940 3, loc.end: 940 8
free_text: type: "c", loc.begin: 940 8, loc.end: 940 16, text: "del_min"
inner_c_end: loc.begin: 940 8, loc.end: 940 16
free_text: type: "tex", loc.begin: 940 16, loc.end: 941 49, text: " operation is even more interesting; this, in fact,
is where most of the action lies. We know that "
inner_c_begin: loc.begin: 940 16, loc.end: 941 49
free_text: type: "c", loc.begin: 941 49, loc.end: 941 56, text: "F_heap"
inner_c_end: loc.begin: 941 49, loc.end: 941 56
free_text: type: "tex", loc.begin: 941 56, loc.end: 943 19, text: " points to the
vertex~$v$ we will be deleting. That's nice, but we need to figure out
the new value of "
inner_c_begin: loc.begin: 941 56, loc.end: 943 19
free_text: type: "c", loc.begin: 943 19, loc.end: 943 26, text: "F_heap"
inner_c_end: loc.begin: 943 19, loc.end: 943 26
tex_section_end: loc.begin: 943 26, loc.end: 961 3
tex_end: loc.begin: 943 26, loc.end: 961 3
c_begin: loc.begin: 943 26, loc.end: 961 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 961 3, loc.end: 962 26, text: "
Vertex *new_roots[46]; "
comment_begin: type: "c", loc.begin: 961 3, loc.end: 962 26
free_text: type: "tex", loc.begin: 962 26, loc.end: 962 68, text: " big enough for queues of size $2^{32}$ "
comment_end: type: "c", loc.begin: 962 26, loc.end: 962 68
free_text: type: "c", loc.begin: 962 68, loc.end: 964 3, text: "

@ "
named_section_end: loc.begin: 962 68, loc.end: 964 3
c_end: loc.begin: 962 68, loc.end: 964 3
tex_begin: loc.begin: 962 68, loc.end: 964 3
tex_section_begin: type: "unstarred", loc.begin: 962 68, loc.end: 964 3
tex_section_end: loc.begin: 964 3, loc.end: 964 5
tex_end: loc.begin: 964 3, loc.end: 964 5
c_begin: loc.begin: 964 3, loc.end: 964 5
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 966 4, loc.end: 966 30, text: "Vertex *final_v=F_heap; "
comment_begin: type: "c", loc.begin: 966 4, loc.end: 966 30
free_text: type: "tex", loc.begin: 966 30, loc.end: 966 52, text: " the node to return "
comment_end: type: "c", loc.begin: 966 30, loc.end: 966 52
free_text: type: "c", loc.begin: 966 52, loc.end: 967 34, text: "
  register Vertex *t,*u,*v,*w; "
comment_begin: type: "c", loc.begin: 966 52, loc.end: 967 34
free_text: type: "tex", loc.begin: 967 34, loc.end: 967 73, text: " registers for manipulation of links "
comment_end: type: "c", loc.begin: 967 34, loc.end: 967 73
free_text: type: "c", loc.begin: 967 73, loc.end: 968 25, text: "
  register long h=-1; "
comment_begin: type: "c", loc.begin: 967 73, loc.end: 968 25
free_text: type: "tex", loc.begin: 968 25, loc.end: 968 55, text: " the highest rank present in "
inner_c_begin: loc.begin: 968 25, loc.end: 968 55
free_text: type: "c", loc.begin: 968 55, loc.end: 968 65, text: "new_roots"
inner_c_end: loc.begin: 968 55, loc.end: 968 65
free_text: type: "tex", loc.begin: 968 65, loc.end: 968 68, text: " "
comment_end: type: "c", loc.begin: 968 65, loc.end: 968 68
free_text: type: "c", loc.begin: 968 68, loc.end: 969 22, text: "
  register long r; "
comment_begin: type: "c", loc.begin: 968 68, loc.end: 969 22
free_text: type: "tex", loc.begin: 969 22, loc.end: 969 46, text: " rank of current tree "
comment_end: type: "c", loc.begin: 969 22, loc.end: 969 46
free_text: type: "c", loc.begin: 969 46, loc.end: 976 11, text: "
  if (F_heap) {
    if (o,F_heap->rank_tag<2) o,v=F_heap->rsib;
    else {
      o,w=F_heap->child;
      o,v=w->rsib;
      oo,w->rsib=F_heap->rsib;
        "
comment_begin: type: "c", loc.begin: 969 46, loc.end: 976 11
free_text: type: "tex", loc.begin: 976 11, loc.end: 976 58, text: " link children of deleted node into the list "
comment_end: type: "c", loc.begin: 976 11, loc.end: 976 58
section_name: name: "Put the tree rooted at |v| into the |new_roots| forest", isPrefix: loc.begin: 976 58, loc.end: 982 9, false
section_name: name: "Rebuild |F_heap| from |new_roots|", isPrefix: loc.begin: 982 9, loc.end: 985 7, false
free_text: type: "c", loc.begin: 985 7, loc.end: 990 3, text: ";
  }
  return final_v;
}

@ "
named_section_end: loc.begin: 985 7, loc.end: 990 3
c_end: loc.begin: 985 7, loc.end: 990 3
tex_begin: loc.begin: 985 7, loc.end: 990 3
tex_section_begin: type: "unstarred", loc.begin: 985 7, loc.end: 990 3
free_text: type: "tex", loc.begin: 990 3, loc.end: 991 24, text: "The work we do in this step is paid for by the unit of potential
energy being freed as "
inner_c_begin: loc.begin: 990 3, loc.end: 991 24
free_text: type: "c", loc.begin: 991 24, loc.end: 991 26, text: "v"
inner_c_end: loc.begin: 991 24, loc.end: 991 26
free_text: type: "tex", loc.begin: 991 26, loc.end: 992 21, text: " leaves the old forest, except for the
work of increasing~"
inner_c_begin: loc.begin: 991 26, loc.end: 992 21
free_text: type: "c", loc.begin: 992 21, loc.end: 992 23, text: "h"
inner_c_end: loc.begin: 992 21, loc.end: 992 23
free_text: type: "tex", loc.begin: 992 23, loc.end: 993 11, text: "; we charge the latter to the $O(\log n)$ cost of
building "
inner_c_begin: loc.begin: 992 23, loc.end: 993 11
free_text: type: "c", loc.begin: 993 11, loc.end: 993 21, text: "new_roots"
inner_c_end: loc.begin: 993 11, loc.end: 993 21
tex_section_end: loc.begin: 993 21, loc.end: 995 3
tex_end: loc.begin: 993 21, loc.end: 995 3
c_begin: loc.begin: 993 21, loc.end: 995 3
named_section_begin: name: "Put the tree rooted at |v| into the |new_roots| forest", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1002 8, loc.end: 1012 27, text: "while (h<r);
    break;
  }
  if (o,new_roots[r]==NULL) {
    o,new_roots[r]=v;
    break;
  }
  u=new_roots[r];
  o,new_roots[r]=NULL;
  if (oo,u->dist<v->dist) {
    o,v->rank_tag=r<<1; "
comment_begin: type: "c", loc.begin: 1002 8, loc.end: 1012 27
free_text: type: "tex", loc.begin: 1012 27, loc.end: 1012 29, text: " "
inner_c_begin: loc.begin: 1012 27, loc.end: 1012 29
free_text: type: "c", loc.begin: 1012 29, loc.end: 1012 31, text: "v"
inner_c_end: loc.begin: 1012 29, loc.end: 1012 31
free_text: type: "tex", loc.begin: 1012 31, loc.end: 1012 72, text: " is not critical and needn't be tagged "
comment_end: type: "c", loc.begin: 1012 31, loc.end: 1012 72
c_format: code: "@+"
c_format: code: "@+"
section_name: name: "Make |u| a child of |v|", isPrefix: loc.begin: 1013 17, loc.end: 1015 5, false
free_text: type: "c", loc.begin: 1015 5, loc.end: 1018 23, text: ";
  r++;
}
o,v->rank_tag=r<<1; "
comment_begin: type: "c", loc.begin: 1015 5, loc.end: 1018 23
free_text: type: "tex", loc.begin: 1018 23, loc.end: 1018 39, text: " every root in "
inner_c_begin: loc.begin: 1018 23, loc.end: 1018 39
free_text: type: "c", loc.begin: 1018 39, loc.end: 1018 49, text: "new_roots"
inner_c_end: loc.begin: 1018 39, loc.end: 1018 49
free_text: type: "tex", loc.begin: 1018 49, loc.end: 1018 64, text: " is untagged "
comment_end: type: "c", loc.begin: 1018 49, loc.end: 1018 64
free_text: type: "c", loc.begin: 1018 64, loc.end: 1020 3, text: "

@ "
named_section_end: loc.begin: 1018 64, loc.end: 1020 3
c_end: loc.begin: 1018 64, loc.end: 1020 3
tex_begin: loc.begin: 1018 64, loc.end: 1020 3
tex_section_begin: type: "unstarred", loc.begin: 1018 64, loc.end: 1020 3
free_text: type: "tex", loc.begin: 1020 3, loc.end: 1020 30, text: "When we get to this step, "
inner_c_begin: loc.begin: 1020 3, loc.end: 1020 30
free_text: type: "c", loc.begin: 1020 30, loc.end: 1020 32, text: "u"
inner_c_end: loc.begin: 1020 30, loc.end: 1020 32
free_text: type: "tex", loc.begin: 1020 32, loc.end: 1020 38, text: " and "
inner_c_begin: loc.begin: 1020 32, loc.end: 1020 38
free_text: type: "c", loc.begin: 1020 38, loc.end: 1020 40, text: "v"
inner_c_end: loc.begin: 1020 38, loc.end: 1020 40
free_text: type: "tex", loc.begin: 1020 40, loc.end: 1020 57, text: " both have rank "
inner_c_begin: loc.begin: 1020 40, loc.end: 1020 57
free_text: type: "c", loc.begin: 1020 57, loc.end: 1020 59, text: "r"
inner_c_end: loc.begin: 1020 57, loc.end: 1020 59
free_text: type: "tex", loc.begin: 1020 59, loc.end: 1021 2, text: ", and
"
inner_c_begin: loc.begin: 1020 59, loc.end: 1021 2
free_text: type: "c", loc.begin: 1021 2, loc.end: 1021 19, text: "u->dist>=v->dist"
inner_c_end: loc.begin: 1021 2, loc.end: 1021 19
free_text: type: "tex", loc.begin: 1021 19, loc.end: 1021 22, text: "; "
inner_c_begin: loc.begin: 1021 19, loc.end: 1021 22
free_text: type: "c", loc.begin: 1021 22, loc.end: 1021 24, text: "u"
inner_c_end: loc.begin: 1021 22, loc.end: 1021 24
tex_section_end: loc.begin: 1021 24, loc.end: 1023 3
tex_end: loc.begin: 1021 24, loc.end: 1023 3
c_begin: loc.begin: 1021 24, loc.end: 1023 3
named_section_begin: name: "Make |u| a child of |v|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1027 4, loc.end: 1035 3, text: "else {
  o,t=v->child;
  oo,u->rsib=t->rsib;
  o,u->lsib=t;
  oo,u->rsib->lsib=t->rsib=u;
}
o,u->parent=v;

@ "
named_section_end: loc.begin: 1027 4, loc.end: 1035 3
c_end: loc.begin: 1027 4, loc.end: 1035 3
tex_begin: loc.begin: 1027 4, loc.end: 1035 3
tex_section_begin: type: "unstarred", loc.begin: 1027 4, loc.end: 1035 3
tex_section_end: loc.begin: 1035 3, loc.end: 1037 3
tex_end: loc.begin: 1035 3, loc.end: 1037 3
c_begin: loc.begin: 1035 3, loc.end: 1037 3
named_section_begin: name: "Rebuild |F_heap| from |new_roots|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1039 9, loc.end: 1039 19, text: "long d; "
comment_begin: type: "c", loc.begin: 1039 9, loc.end: 1039 19
free_text: type: "tex", loc.begin: 1039 19, loc.end: 1039 53, text: " smallest key value seen so far "
comment_end: type: "c", loc.begin: 1039 19, loc.end: 1039 53
free_text: type: "c", loc.begin: 1039 53, loc.end: 1041 6, text: "
  o,u=v=new_roots[h];
   "
comment_begin: type: "c", loc.begin: 1039 53, loc.end: 1041 6
free_text: type: "tex", loc.begin: 1041 6, loc.end: 1041 8, text: " "
inner_c_begin: loc.begin: 1041 6, loc.end: 1041 8
free_text: type: "c", loc.begin: 1041 8, loc.end: 1041 10, text: "u"
inner_c_end: loc.begin: 1041 8, loc.end: 1041 10
free_text: type: "tex", loc.begin: 1041 10, loc.end: 1041 16, text: " and "
inner_c_begin: loc.begin: 1041 10, loc.end: 1041 16
free_text: type: "c", loc.begin: 1041 16, loc.end: 1041 18, text: "v"
inner_c_end: loc.begin: 1041 16, loc.end: 1041 18
free_text: type: "tex", loc.begin: 1041 18, loc.end: 1041 75, text: " will point to beginning and end of list, respectively "
comment_end: type: "c", loc.begin: 1041 18, loc.end: 1041 75
free_text: type: "c", loc.begin: 1041 75, loc.end: 1059 3, text: "
  o,d=u->dist;
  F_heap=u;
  for (h--;h>=0;h--)
    if (o,new_roots[h]) {
      w=new_roots[h];
      o,w->lsib=v;
      o,v->rsib=w;
      if (o,w->dist<d) {
        F_heap=w;
        d=w->dist;
      }
      v=w;
    }
  o,v->rsib=u;
  o,u->lsib=v;
}

@ "
named_section_end: loc.begin: 1041 75, loc.end: 1059 3
c_end: loc.begin: 1041 75, loc.end: 1059 3
tex_begin: loc.begin: 1041 75, loc.end: 1059 3
tex_section_begin: type: "unstarred", loc.begin: 1041 75, loc.end: 1059 3
tex_section_end: loc.begin: 1059 3, loc.end: 1059 5
tex_end: loc.begin: 1059 3, loc.end: 1059 5
c_begin: loc.begin: 1059 3, loc.end: 1059 5
named_section_begin: name: "Execute |jar_pr(g)| with Fibonacci heaps...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1059 5, loc.end: 1065 11, text: "
init_queue=init_F_heap;
enqueue=enq_F_heap;
requeue=req_F_heap;
del_min=del_F_heap;
if (sp_length!=jar_pr(g)) {
  printf("
string_begin: type: "c", loc.begin: 1059 5, loc.end: 1065 11
free_text: type: "tex", loc.begin: 1065 11, loc.end: 1065 58, text: " ...oops, I've got a bug, please fix fix fix\n"
string_end: type: "c", loc.begin: 1065 11, loc.end: 1065 58
free_text: type: "c", loc.begin: 1065 58, loc.end: 1069 19, text: ");
  return -5;
}

@*"
named_section_end: loc.begin: 1065 58, loc.end: 1069 19
c_end: loc.begin: 1065 58, loc.end: 1069 19
tex_begin: loc.begin: 1065 58, loc.end: 1069 19
tex_section_begin: type: "starred", title: "Binomial queues.", loc.begin: 1065 58, loc.end: 1069 19
index_entry: entry: "Vuillemin, Jean Etienne", loc.begin: 1069 19, loc.end: 1071 28
free_text: type: "tex", loc.begin: 1071 28, loc.end: 1090 60, text: "
309--314] provide yet another appealing way to maintain priority queues.
A binomial queue is a forest of trees with keys ordered as in Fibonacci
heaps, satisfying two conditions that are considerably stronger than
the Fibonacci heap property: Each node of rank~$k$ has children of
respective ranks $\{0,1,\ldots,k-1\}$; and each root of the forest
has a different rank. It follows that each node of rank~$k$ has exactly
$2^k$ descendants (including itself), and that a binomial queue of
$n$ elements has exactly as many trees as the number $n$ has 1's in
binary notation.

We could plug binomial queues into the Jarn{\'\i}k/Prim algorithm, but
they don't offer advantages over the heap methods already considered
because they don't support the requeueing operation as nicely.
Binomial queues do, however, permit efficient merging---the operation
of combining two priority queues into one---and they achieve this
without as much space overhead as Fibonacci heaps. In fact, we can
implement binomial queues with only two pointers per node, namely a
pointer to the largest child and another to the next sibling. This means we
have just enough space in the utility fields of GraphBase "
inner_c_begin: loc.begin: 1071 28, loc.end: 1090 60
free_text: type: "c", loc.begin: 1090 60, loc.end: 1090 64, text: "Arc"
inner_c_end: loc.begin: 1090 60, loc.end: 1090 64
index_entry: entry: "Knuth, Nancy Jill Carter", loc.begin: 1090 64, loc.end: 1104 29
tex_section_end: loc.begin: 1104 29, loc.end: 1108 3
tex_end: loc.begin: 1104 29, loc.end: 1108 3
middle_begin: loc.begin: 1104 29, loc.end: 1108 3
macro_begin: name: "qchild", params: {}, loc.begin: 1108 3, loc.end: 1109 3, text: "qchild "
macro_end: loc.begin: 1108 3, loc.end: 1109 3
macro_begin: name: "qsib", params: {}, loc.begin: 1109 3, loc.end: 1111 3, text: "qsib "
free_text: type: "c", loc.begin: 1109 3, loc.end: 1111 3, text: "b.A /* pointer to next larger sibling, or from largest to smallest */

@ "
macro_end: loc.begin: 1109 3, loc.end: 1111 3
middle_end: loc.begin: 1109 3, loc.end: 1111 3
tex_begin: loc.begin: 1109 3, loc.end: 1111 3
tex_section_begin: type: "unstarred", loc.begin: 1109 3, loc.end: 1111 3
free_text: type: "tex", loc.begin: 1111 3, loc.end: 1112 24, text: "A special header node is used at the head of a binomial queue, to represent
the queue itself. The "
inner_c_begin: loc.begin: 1111 3, loc.end: 1112 24
free_text: type: "c", loc.begin: 1112 24, loc.end: 1112 29, text: "qsib"
inner_c_end: loc.begin: 1112 24, loc.end: 1112 29
free_text: type: "tex", loc.begin: 1112 29, loc.end: 1114 41, text: " field of this node points to the smallest
root node in the forest. (``Smallest'' means smallest in rank, not in
key value.) The header also contains a "
inner_c_begin: loc.begin: 1112 29, loc.end: 1114 41
free_text: type: "c", loc.begin: 1114 41, loc.end: 1114 48, text: "qcount"
inner_c_end: loc.begin: 1114 41, loc.end: 1114 48
free_text: type: "tex", loc.begin: 1114 48, loc.end: 1115 21, text: " field, which
takes the place of "
inner_c_begin: loc.begin: 1114 48, loc.end: 1115 21
free_text: type: "c", loc.begin: 1115 21, loc.end: 1115 28, text: "qchild"
inner_c_end: loc.begin: 1115 21, loc.end: 1115 28
free_text: type: "tex", loc.begin: 1115 28, loc.end: 1115 35, text: "; the "
inner_c_begin: loc.begin: 1115 28, loc.end: 1115 35
free_text: type: "c", loc.begin: 1115 35, loc.end: 1115 42, text: "qcount"
inner_c_end: loc.begin: 1115 35, loc.end: 1115 42
free_text: type: "tex", loc.begin: 1115 42, loc.end: 1117 18, text: " is the total number of nodes,
so its binary representation characterizes the sizes of the trees
accessible from "
inner_c_begin: loc.begin: 1115 42, loc.end: 1117 18
free_text: type: "c", loc.begin: 1117 18, loc.end: 1117 23, text: "qsib"
inner_c_end: loc.begin: 1117 18, loc.end: 1117 23
free_text: type: "tex", loc.begin: 1117 23, loc.end: 1119 48, text: ".

For example, suppose a queue with header node "
inner_c_begin: loc.begin: 1117 23, loc.end: 1119 48
free_text: type: "c", loc.begin: 1119 48, loc.end: 1119 50, text: "h"
inner_c_end: loc.begin: 1119 48, loc.end: 1119 50
free_text: type: "tex", loc.begin: 1119 50, loc.end: 1124 2, text: " contains five elements
$\{a,b,c,d,e\}$ whose keys happen to be ordered alphabetically. The first
tree might be the single node~$c$; the other tree might be rooted at~$a$,
with children $e$ and~$b$. Then we have
$$\vbox{\halign{#\hfil&\qquad#\hfil\cr
"
inner_c_begin: loc.begin: 1119 50, loc.end: 1124 2
free_text: type: "c", loc.begin: 1124 2, loc.end: 1124 14, text: "h->qcount=5"
inner_c_end: loc.begin: 1124 2, loc.end: 1124 14
free_text: type: "tex", loc.begin: 1124 14, loc.end: 1124 17, text: ",&"
inner_c_begin: loc.begin: 1124 14, loc.end: 1124 17
free_text: type: "c", loc.begin: 1124 17, loc.end: 1124 27, text: "h->qsib=c"
inner_c_end: loc.begin: 1124 17, loc.end: 1124 27
free_text: type: "tex", loc.begin: 1124 27, loc.end: 1125 2, text: ";\cr
"
inner_c_begin: loc.begin: 1124 27, loc.end: 1125 2
free_text: type: "c", loc.begin: 1125 2, loc.end: 1125 12, text: "c->qsib=a"
inner_c_end: loc.begin: 1125 2, loc.end: 1125 12
free_text: type: "tex", loc.begin: 1125 12, loc.end: 1126 2, text: ";\cr
"
inner_c_begin: loc.begin: 1125 12, loc.end: 1126 2
free_text: type: "c", loc.begin: 1126 2, loc.end: 1126 14, text: "a->qchild=b"
inner_c_end: loc.begin: 1126 2, loc.end: 1126 14
free_text: type: "tex", loc.begin: 1126 14, loc.end: 1127 2, text: ";\cr
"
inner_c_begin: loc.begin: 1126 14, loc.end: 1127 2
free_text: type: "c", loc.begin: 1127 2, loc.end: 1127 14, text: "b->qchild=d"
inner_c_end: loc.begin: 1127 2, loc.end: 1127 14
free_text: type: "tex", loc.begin: 1127 14, loc.end: 1127 17, text: ",&"
inner_c_begin: loc.begin: 1127 14, loc.end: 1127 17
free_text: type: "c", loc.begin: 1127 17, loc.end: 1127 27, text: "b->qsib=e"
inner_c_end: loc.begin: 1127 17, loc.end: 1127 27
free_text: type: "tex", loc.begin: 1127 27, loc.end: 1128 2, text: ";\cr
"
inner_c_begin: loc.begin: 1127 27, loc.end: 1128 2
free_text: type: "c", loc.begin: 1128 2, loc.end: 1128 12, text: "e->qsib=b"
inner_c_end: loc.begin: 1128 2, loc.end: 1128 12
free_text: type: "tex", loc.begin: 1128 12, loc.end: 1129 19, text: ".\cr}}$$
The other fields "
inner_c_begin: loc.begin: 1128 12, loc.end: 1129 19
free_text: type: "c", loc.begin: 1129 19, loc.end: 1129 29, text: "c->qchild"
inner_c_end: loc.begin: 1129 19, loc.end: 1129 29
free_text: type: "tex", loc.begin: 1129 29, loc.end: 1129 32, text: ", "
inner_c_begin: loc.begin: 1129 29, loc.end: 1129 32
free_text: type: "c", loc.begin: 1129 32, loc.end: 1129 40, text: "a->qsib"
inner_c_end: loc.begin: 1129 32, loc.end: 1129 40
free_text: type: "tex", loc.begin: 1129 40, loc.end: 1129 43, text: ", "
inner_c_begin: loc.begin: 1129 40, loc.end: 1129 43
free_text: type: "c", loc.begin: 1129 43, loc.end: 1129 53, text: "e->qchild"
inner_c_end: loc.begin: 1129 43, loc.end: 1129 53
free_text: type: "tex", loc.begin: 1129 53, loc.end: 1129 56, text: ", "
inner_c_begin: loc.begin: 1129 53, loc.end: 1129 56
free_text: type: "c", loc.begin: 1129 56, loc.end: 1129 64, text: "d->qsib"
inner_c_end: loc.begin: 1129 56, loc.end: 1129 64
free_text: type: "tex", loc.begin: 1129 64, loc.end: 1130 2, text: ", and
"
inner_c_begin: loc.begin: 1129 64, loc.end: 1130 2
free_text: type: "c", loc.begin: 1130 2, loc.end: 1130 12, text: "d->qchild"
inner_c_end: loc.begin: 1130 2, loc.end: 1130 12
free_text: type: "tex", loc.begin: 1130 12, loc.end: 1133 37, text: " are undefined. We can save time by not loading or storing the
undefined fields, which make up about 3/8 of the structure.

An empty binomial queue would have "
inner_c_begin: loc.begin: 1130 12, loc.end: 1133 37
free_text: type: "c", loc.begin: 1133 37, loc.end: 1133 49, text: "h->qcount=0"
inner_c_end: loc.begin: 1133 37, loc.end: 1133 49
free_text: type: "tex", loc.begin: 1133 49, loc.end: 1133 55, text: " and "
inner_c_begin: loc.begin: 1133 49, loc.end: 1133 55
free_text: type: "c", loc.begin: 1133 55, loc.end: 1133 63, text: "h->qsib"
inner_c_end: loc.begin: 1133 55, loc.end: 1133 63
tex_section_end: loc.begin: 1133 63, loc.end: 1138 3
tex_end: loc.begin: 1133 63, loc.end: 1138 3
middle_begin: loc.begin: 1133 63, loc.end: 1138 3
macro_begin: name: "qcount", params: {}, loc.begin: 1138 3, loc.end: 1140 3, text: "qcount "
free_text: type: "c", loc.begin: 1138 3, loc.end: 1140 3, text: "a.I /* this field takes the place of |qchild| in header nodes */

@ "
macro_end: loc.begin: 1138 3, loc.end: 1140 3
middle_end: loc.begin: 1138 3, loc.end: 1140 3
tex_begin: loc.begin: 1138 3, loc.end: 1140 3
tex_section_begin: type: "unstarred", loc.begin: 1138 3, loc.end: 1140 3
free_text: type: "tex", loc.begin: 1140 3, loc.end: 1141 59, text: "Most of the operations we want to do with binomial queues rely on
the following basic subroutine, which merges a forest of "
inner_c_begin: loc.begin: 1140 3, loc.end: 1141 59
free_text: type: "c", loc.begin: 1141 59, loc.end: 1141 61, text: "m"
inner_c_end: loc.begin: 1141 59, loc.end: 1141 61
free_text: type: "tex", loc.begin: 1141 61, loc.end: 1142 14, text: " nodes
starting at "
inner_c_begin: loc.begin: 1141 61, loc.end: 1142 14
free_text: type: "c", loc.begin: 1142 14, loc.end: 1142 16, text: "q"
inner_c_end: loc.begin: 1142 14, loc.end: 1142 16
free_text: type: "tex", loc.begin: 1142 16, loc.end: 1142 35, text: " with a forest of "
inner_c_begin: loc.begin: 1142 16, loc.end: 1142 35
free_text: type: "c", loc.begin: 1142 35, loc.end: 1142 38, text: "mm"
inner_c_end: loc.begin: 1142 35, loc.end: 1142 38
free_text: type: "tex", loc.begin: 1142 38, loc.end: 1142 58, text: " nodes starting at "
inner_c_begin: loc.begin: 1142 38, loc.end: 1142 58
free_text: type: "c", loc.begin: 1142 58, loc.end: 1142 61, text: "qq"
inner_c_end: loc.begin: 1142 58, loc.end: 1142 61
free_text: type: "tex", loc.begin: 1142 61, loc.end: 1143 39, text: ", putting
a pointer to the resulting forest of "
inner_c_begin: loc.begin: 1142 61, loc.end: 1143 39
free_text: type: "c", loc.begin: 1143 39, loc.end: 1143 44, text: "m+mm"
inner_c_end: loc.begin: 1143 39, loc.end: 1143 44
free_text: type: "tex", loc.begin: 1143 44, loc.end: 1143 57, text: " nodes into "
inner_c_begin: loc.begin: 1143 44, loc.end: 1143 57
free_text: type: "c", loc.begin: 1143 57, loc.end: 1143 65, text: "h->qsib"
inner_c_end: loc.begin: 1143 57, loc.end: 1143 65
free_text: type: "tex", loc.begin: 1143 65, loc.end: 1144 60, text: ".
The amortized running time is $O(\log m)$, independent of "
inner_c_begin: loc.begin: 1143 65, loc.end: 1144 60
free_text: type: "c", loc.begin: 1144 60, loc.end: 1144 63, text: "mm"
inner_c_end: loc.begin: 1144 60, loc.end: 1144 63
free_text: type: "tex", loc.begin: 1144 63, loc.end: 1146 6, text: ".

The "
inner_c_begin: loc.begin: 1144 63, loc.end: 1146 6
free_text: type: "c", loc.begin: 1146 6, loc.end: 1146 10, text: "len"
inner_c_end: loc.begin: 1146 6, loc.end: 1146 10
free_text: type: "tex", loc.begin: 1146 10, loc.end: 1146 23, text: " field, not "
inner_c_begin: loc.begin: 1146 10, loc.end: 1146 23
free_text: type: "c", loc.begin: 1146 23, loc.end: 1146 28, text: "dist"
inner_c_end: loc.begin: 1146 23, loc.end: 1146 28
tex_section_end: loc.begin: 1146 28, loc.end: 1149 3
tex_end: loc.begin: 1146 28, loc.end: 1149 3
c_begin: loc.begin: 1146 28, loc.end: 1149 3
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1149 3, loc.end: 1151 25, text: "
qunite(m,q,mm,qq,h)
  register long m,mm; "
comment_begin: type: "c", loc.begin: 1149 3, loc.end: 1151 25
free_text: type: "tex", loc.begin: 1151 25, loc.end: 1151 59, text: " number of nodes in the forests "
comment_end: type: "c", loc.begin: 1151 25, loc.end: 1151 59
free_text: type: "c", loc.begin: 1151 59, loc.end: 1152 26, text: "
  register Arc *q,*qq; "
comment_begin: type: "c", loc.begin: 1151 59, loc.end: 1152 26
free_text: type: "tex", loc.begin: 1152 26, loc.end: 1152 69, text: " binomial trees in the forests, linked by "
inner_c_begin: loc.begin: 1152 26, loc.end: 1152 69
free_text: type: "c", loc.begin: 1152 69, loc.end: 1152 74, text: "qsib"
inner_c_end: loc.begin: 1152 69, loc.end: 1152 74
free_text: type: "tex", loc.begin: 1152 74, loc.end: 1152 77, text: " "
comment_end: type: "c", loc.begin: 1152 74, loc.end: 1152 77
free_text: type: "c", loc.begin: 1152 77, loc.end: 1153 13, text: "
  Arc *h; "
comment_begin: type: "c", loc.begin: 1152 77, loc.end: 1153 13
free_text: type: "tex", loc.begin: 1153 13, loc.end: 1153 15, text: " "
inner_c_begin: loc.begin: 1153 13, loc.end: 1153 15
free_text: type: "c", loc.begin: 1153 15, loc.end: 1153 23, text: "h->qsib"
inner_c_end: loc.begin: 1153 15, loc.end: 1153 23
free_text: type: "tex", loc.begin: 1153 23, loc.end: 1153 46, text: " will get the result "
comment_end: type: "c", loc.begin: 1153 23, loc.end: 1153 46
c_format: code: "@+"
free_text: type: "c", loc.begin: 1154 4, loc.end: 1154 23, text: "register Arc *p; "
comment_begin: type: "c", loc.begin: 1154 4, loc.end: 1154 23
free_text: type: "tex", loc.begin: 1154 23, loc.end: 1154 56, text: " tail of the list built so far "
comment_end: type: "c", loc.begin: 1154 23, loc.end: 1154 56
free_text: type: "c", loc.begin: 1154 56, loc.end: 1155 24, text: "
  register long k=1; "
comment_begin: type: "c", loc.begin: 1154 56, loc.end: 1155 24
free_text: type: "tex", loc.begin: 1155 24, loc.end: 1155 67, text: " size of trees currently being processed "
comment_end: type: "c", loc.begin: 1155 24, loc.end: 1155 67
free_text: type: "c", loc.begin: 1155 67, loc.end: 1159 21, text: "
  p=h;
  while (m) {
    if ((m&k)==0) {
      if (mm&k) { "
comment_begin: type: "c", loc.begin: 1155 67, loc.end: 1159 21
free_text: type: "tex", loc.begin: 1159 21, loc.end: 1159 23, text: " "
inner_c_begin: loc.begin: 1159 21, loc.end: 1159 23
free_text: type: "c", loc.begin: 1159 23, loc.end: 1159 26, text: "qq"
inner_c_end: loc.begin: 1159 23, loc.end: 1159 26
free_text: type: "tex", loc.begin: 1159 26, loc.end: 1159 55, text: " goes into the merged list "
comment_end: type: "c", loc.begin: 1159 26, loc.end: 1159 55
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1163 8, loc.end: 1163 32, text: "else if ((mm&k)==0) { "
comment_begin: type: "c", loc.begin: 1163 8, loc.end: 1163 32
free_text: type: "tex", loc.begin: 1163 32, loc.end: 1163 34, text: " "
inner_c_begin: loc.begin: 1163 32, loc.end: 1163 34
free_text: type: "c", loc.begin: 1163 34, loc.end: 1163 36, text: "q"
inner_c_end: loc.begin: 1163 34, loc.end: 1163 36
free_text: type: "tex", loc.begin: 1163 36, loc.end: 1163 65, text: " goes into the merged list "
comment_end: type: "c", loc.begin: 1163 36, loc.end: 1163 65
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
section_name: name: "Combine |q| and |qq| into a ``carry'' tree, and continue
             merging until the carry no longer propagates", isPrefix: loc.begin: 1166 8, loc.end: 1166 15, false
free_text: type: "c", loc.begin: 1166 15, loc.end: 1172 3, text: ";
    k<<=1;
  }
  if (mm) o,p->qsib=qq;
}
    
@ "
named_section_end: loc.begin: 1166 15, loc.end: 1172 3
c_end: loc.begin: 1166 15, loc.end: 1172 3
tex_begin: loc.begin: 1166 15, loc.end: 1172 3
tex_section_begin: type: "unstarred", loc.begin: 1166 15, loc.end: 1172 3
free_text: type: "tex", loc.begin: 1172 3, loc.end: 1175 59, text: "As we have seen in Fibonacci heaps, two heap-ordered trees can be combined
by simply attaching one as a new child of the other. This operation preserves
binomial trees. (In fact, if we use Fibonacci heaps without ever doing
a requeue operation, the forests that appear after every "
inner_c_begin: loc.begin: 1172 3, loc.end: 1175 59
free_text: type: "c", loc.begin: 1175 59, loc.end: 1175 67, text: "del_min"
inner_c_end: loc.begin: 1175 59, loc.end: 1175 67
tex_section_end: loc.begin: 1175 67, loc.end: 1179 3
tex_end: loc.begin: 1175 67, loc.end: 1179 3
c_begin: loc.begin: 1175 67, loc.end: 1179 3
named_section_begin: name: "Combine |q| and |qq| into a ``carry'' tree, and continue
             merging until the carry no longer propagates", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1180 4, loc.end: 1180 23, text: "register Arc *c; "
comment_begin: type: "c", loc.begin: 1180 4, loc.end: 1180 23
free_text: type: "tex", loc.begin: 1180 23, loc.end: 1180 55, text: " the ``carry,'' a tree of size "
inner_c_begin: loc.begin: 1180 23, loc.end: 1180 55
free_text: type: "c", loc.begin: 1180 55, loc.end: 1180 58, text: "2k"
inner_c_end: loc.begin: 1180 55, loc.end: 1180 58
free_text: type: "tex", loc.begin: 1180 58, loc.end: 1180 61, text: " "
comment_end: type: "c", loc.begin: 1180 58, loc.end: 1180 61
free_text: type: "c", loc.begin: 1180 61, loc.end: 1181 24, text: "
  register long key; "
comment_begin: type: "c", loc.begin: 1180 61, loc.end: 1181 24
free_text: type: "tex", loc.begin: 1181 24, loc.end: 1181 26, text: " "
inner_c_begin: loc.begin: 1181 24, loc.end: 1181 26
free_text: type: "c", loc.begin: 1181 26, loc.end: 1181 33, text: "c->len"
inner_c_end: loc.begin: 1181 26, loc.end: 1181 33
free_text: type: "tex", loc.begin: 1181 33, loc.end: 1181 36, text: " "
comment_end: type: "c", loc.begin: 1181 33, loc.end: 1181 36
free_text: type: "c", loc.begin: 1181 36, loc.end: 1182 26, text: "
  register Arc *r,*rr; "
comment_begin: type: "c", loc.begin: 1181 36, loc.end: 1182 26
free_text: type: "tex", loc.begin: 1182 26, loc.end: 1182 59, text: " remainders of the input lists "
comment_end: type: "c", loc.begin: 1182 26, loc.end: 1182 59
c_format: code: "@+"
c_format: code: "@+"
section_name: name: "Set |c| to the combination of |q| and |qq|", isPrefix: loc.begin: 1184 11, loc.end: 1185 5, false
c_format: code: "@+"
c_format: code: "@+"
section_name: name: "Merge |qq| into |c| and advance |qq|", isPrefix: loc.begin: 1186 17, loc.end: 1188 21, false
c_format: code: "@;"
section_name: name: "Merge |q| into |c| and advance |q|", isPrefix: loc.begin: 1188 23, loc.end: 1190 9, false
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1198 17, loc.end: 1201 3, text: "p=c;
}

@ "
named_section_end: loc.begin: 1198 17, loc.end: 1201 3
c_end: loc.begin: 1198 17, loc.end: 1201 3
tex_begin: loc.begin: 1198 17, loc.end: 1201 3
tex_section_begin: type: "unstarred", loc.begin: 1198 17, loc.end: 1201 3
tex_section_end: loc.begin: 1201 3, loc.end: 1201 5
tex_end: loc.begin: 1201 3, loc.end: 1201 5
c_begin: loc.begin: 1201 3, loc.end: 1201 5
named_section_begin: name: "Set |c| to the combination of |q| and |qq|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1205 4, loc.end: 1215 3, text: "else c=qq,key=qq->len;
if (k==1) o,c->qchild=q;
else {
  o,qq=c->qchild;
  o,c->qchild=q;
  if (k==2) o,q->qsib=qq;
  else oo,q->qsib=qq->qsib;
  o,qq->qsib=q;
}

@ "
named_section_end: loc.begin: 1205 4, loc.end: 1215 3
c_end: loc.begin: 1205 4, loc.end: 1215 3
tex_begin: loc.begin: 1205 4, loc.end: 1215 3
tex_section_begin: type: "unstarred", loc.begin: 1205 4, loc.end: 1215 3
free_text: type: "tex", loc.begin: 1215 3, loc.end: 1215 19, text: "At this point, "
inner_c_begin: loc.begin: 1215 3, loc.end: 1215 19
free_text: type: "c", loc.begin: 1215 19, loc.end: 1215 23, text: "k>1"
inner_c_end: loc.begin: 1215 19, loc.end: 1215 23
tex_section_end: loc.begin: 1215 23, loc.end: 1217 3
tex_end: loc.begin: 1215 23, loc.end: 1217 3
c_begin: loc.begin: 1215 23, loc.end: 1217 3
named_section_begin: name: "Merge |q| into |c| and advance |q|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1221 31, loc.end: 1231 3, text: "q=rr;
  }
  o,rr=c->qchild;
  o,c->qchild=q;
  if (k==2) o,q->qsib=rr;
  else oo,q->qsib=rr->qsib;
  o,rr->qsib=q;
  q=r;
}

@ "
named_section_end: loc.begin: 1221 31, loc.end: 1231 3
c_end: loc.begin: 1221 31, loc.end: 1231 3
tex_begin: loc.begin: 1221 31, loc.end: 1231 3
tex_section_begin: type: "unstarred", loc.begin: 1221 31, loc.end: 1231 3
tex_section_end: loc.begin: 1231 3, loc.end: 1231 5
tex_end: loc.begin: 1231 3, loc.end: 1231 5
c_begin: loc.begin: 1231 3, loc.end: 1231 5
named_section_begin: name: "Merge |qq| into |c| and advance |qq|", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1235 32, loc.end: 1245 3, text: "qq=r;
  }
  o,r=c->qchild;
  o,c->qchild=qq;
  if (k==2) o,qq->qsib=r;
  else oo,qq->qsib=r->qsib;
  o,r->qsib=qq;
  qq=rr;
}

@ "
named_section_end: loc.begin: 1235 32, loc.end: 1245 3
c_end: loc.begin: 1235 32, loc.end: 1245 3
tex_begin: loc.begin: 1235 32, loc.end: 1245 3
tex_section_begin: type: "unstarred", loc.begin: 1235 32, loc.end: 1245 3
free_text: type: "tex", loc.begin: 1245 3, loc.end: 1246 8, text: "OK, now the hard work is done and we can reap the benefits of the
basic "
inner_c_begin: loc.begin: 1245 3, loc.end: 1246 8
free_text: type: "c", loc.begin: 1246 8, loc.end: 1246 15, text: "qunite"
inner_c_end: loc.begin: 1246 8, loc.end: 1246 15
tex_section_end: loc.begin: 1246 15, loc.end: 1249 3
tex_end: loc.begin: 1246 15, loc.end: 1249 3
c_begin: loc.begin: 1246 15, loc.end: 1249 3
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1249 3, loc.end: 1251 13, text: "
qenque(h,a)
  Arc *h; "
comment_begin: type: "c", loc.begin: 1249 3, loc.end: 1251 13
free_text: type: "tex", loc.begin: 1251 13, loc.end: 1251 43, text: " header of a binomial queue "
comment_end: type: "c", loc.begin: 1251 13, loc.end: 1251 43
free_text: type: "c", loc.begin: 1251 43, loc.end: 1252 13, text: "
  Arc *a; "
comment_begin: type: "c", loc.begin: 1251 43, loc.end: 1252 13
free_text: type: "tex", loc.begin: 1252 13, loc.end: 1252 43, text: " new element for that queue "
comment_end: type: "c", loc.begin: 1252 13, loc.end: 1252 43
c_format: code: "@+"
free_text: type: "c", loc.begin: 1253 4, loc.end: 1260 3, text: "long m;
  o,m=h->qcount;
  o,h->qcount=m+1;
  if (m==0) o,h->qsib=a;
  else o,qunite(1L,a,m,h->qsib,h);
}

@ "
named_section_end: loc.begin: 1253 4, loc.end: 1260 3
c_end: loc.begin: 1253 4, loc.end: 1260 3
tex_begin: loc.begin: 1253 4, loc.end: 1260 3
tex_section_begin: type: "unstarred", loc.begin: 1253 4, loc.end: 1260 3
tex_section_end: loc.begin: 1260 3, loc.end: 1264 3
tex_end: loc.begin: 1260 3, loc.end: 1264 3
c_begin: loc.begin: 1260 3, loc.end: 1264 3
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1264 3, loc.end: 1266 13, text: "
qmerge(h,hh)
  Arc *h; "
comment_begin: type: "c", loc.begin: 1264 3, loc.end: 1266 13
free_text: type: "tex", loc.begin: 1266 13, loc.end: 1266 70, text: " header of binomial queue that will receive the result "
comment_end: type: "c", loc.begin: 1266 13, loc.end: 1266 70
free_text: type: "c", loc.begin: 1266 70, loc.end: 1267 14, text: "
  Arc *hh; "
comment_begin: type: "c", loc.begin: 1266 70, loc.end: 1267 14
free_text: type: "tex", loc.begin: 1267 14, loc.end: 1267 64, text: " header of binomial queue that will be absorbed "
comment_end: type: "c", loc.begin: 1267 14, loc.end: 1267 64
c_format: code: "@+"
free_text: type: "c", loc.begin: 1268 4, loc.end: 1279 3, text: "long m,mm;
  o,mm=hh->qcount;
  if (mm) {
    o,m=h->qcount;
    o,h->qcount=m+mm;
    if (m>=mm) oo,qunite(mm,hh->qsib,m,h->qsib,h);
    else if (m==0) oo,h->qsib=hh->qsib;
    else oo,qunite(m,h->qsib,mm,hh->qsib,h);
  }
} 

@ "
named_section_end: loc.begin: 1268 4, loc.end: 1279 3
c_end: loc.begin: 1268 4, loc.end: 1279 3
tex_begin: loc.begin: 1268 4, loc.end: 1279 3
tex_section_begin: type: "unstarred", loc.begin: 1268 4, loc.end: 1279 3
tex_section_end: loc.begin: 1279 3, loc.end: 1283 3
tex_end: loc.begin: 1279 3, loc.end: 1283 3
c_begin: loc.begin: 1279 3, loc.end: 1283 3
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1283 3, loc.end: 1285 13, text: "
Arc *qdel_min(h)
  Arc *h; "
comment_begin: type: "c", loc.begin: 1283 3, loc.end: 1285 13
free_text: type: "tex", loc.begin: 1285 13, loc.end: 1285 41, text: " header of binomial queue "
comment_end: type: "c", loc.begin: 1285 13, loc.end: 1285 41
c_format: code: "@+"
free_text: type: "c", loc.begin: 1286 4, loc.end: 1286 27, text: "register Arc *p,*pp; "
comment_begin: type: "c", loc.begin: 1286 4, loc.end: 1286 27
free_text: type: "tex", loc.begin: 1286 27, loc.end: 1286 63, text: " current node and its predecessor "
comment_end: type: "c", loc.begin: 1286 27, loc.end: 1286 63
free_text: type: "c", loc.begin: 1286 63, loc.end: 1287 26, text: "
  register Arc *q,*qq; "
comment_begin: type: "c", loc.begin: 1286 63, loc.end: 1287 26
free_text: type: "tex", loc.begin: 1287 26, loc.end: 1287 70, text: " current minimum node and its predecessor "
comment_end: type: "c", loc.begin: 1287 26, loc.end: 1287 70
free_text: type: "c", loc.begin: 1287 70, loc.end: 1288 24, text: "
  register long key; "
comment_begin: type: "c", loc.begin: 1287 70, loc.end: 1288 24
free_text: type: "tex", loc.begin: 1288 24, loc.end: 1288 26, text: " "
inner_c_begin: loc.begin: 1288 24, loc.end: 1288 26
free_text: type: "c", loc.begin: 1288 26, loc.end: 1288 33, text: "q->len"
inner_c_end: loc.begin: 1288 26, loc.end: 1288 33
free_text: type: "tex", loc.begin: 1288 33, loc.end: 1288 67, text: ", the smallest key known so far "
comment_end: type: "c", loc.begin: 1288 33, loc.end: 1288 67
free_text: type: "c", loc.begin: 1288 67, loc.end: 1289 13, text: "
  long m; "
comment_begin: type: "c", loc.begin: 1288 67, loc.end: 1289 13
free_text: type: "tex", loc.begin: 1289 13, loc.end: 1289 45, text: " number of nodes in the queue "
comment_end: type: "c", loc.begin: 1289 13, loc.end: 1289 45
free_text: type: "c", loc.begin: 1289 45, loc.end: 1290 13, text: "
  long k; "
comment_begin: type: "c", loc.begin: 1289 45, loc.end: 1290 13
free_text: type: "tex", loc.begin: 1290 13, loc.end: 1290 39, text: " number of nodes in tree "
inner_c_begin: loc.begin: 1290 13, loc.end: 1290 39
free_text: type: "c", loc.begin: 1290 39, loc.end: 1290 41, text: "q"
inner_c_end: loc.begin: 1290 39, loc.end: 1290 41
free_text: type: "tex", loc.begin: 1290 41, loc.end: 1290 44, text: " "
comment_end: type: "c", loc.begin: 1290 41, loc.end: 1290 44
free_text: type: "c", loc.begin: 1290 44, loc.end: 1291 23, text: "
  register long mm; "
comment_begin: type: "c", loc.begin: 1290 44, loc.end: 1291 23
free_text: type: "tex", loc.begin: 1291 23, loc.end: 1291 61, text: " number of nodes not yet considered "
comment_end: type: "c", loc.begin: 1291 23, loc.end: 1291 61
section_name: name: "Find and remove a tree whose root |q| has the smallest key", isPrefix: loc.begin: 1291 61, loc.end: 1295 5, false
c_format: code: "@+"
free_text: type: "c", loc.begin: 1299 6, loc.end: 1303 3, text: "else if (k==2) o,qunite(1L,q->qchild,m-k,h->qsib,h);
  return q;
}

@ "
named_section_end: loc.begin: 1299 6, loc.end: 1303 3
c_end: loc.begin: 1299 6, loc.end: 1303 3
tex_begin: loc.begin: 1299 6, loc.end: 1303 3
tex_section_begin: type: "unstarred", loc.begin: 1299 6, loc.end: 1303 3
free_text: type: "tex", loc.begin: 1303 3, loc.end: 1305 63, text: "If the tree with smallest key is the largest in the forest,
we don't have to change any links to remove it,
because our binomial queue algorithms never look at the last "
inner_c_begin: loc.begin: 1303 3, loc.end: 1305 63
free_text: type: "c", loc.begin: 1305 63, loc.end: 1305 68, text: "qsib"
inner_c_end: loc.begin: 1305 63, loc.end: 1305 68
free_text: type: "tex", loc.begin: 1305 68, loc.end: 1307 43, text: " pointer.

We use a well-known binary number trick: "
inner_c_begin: loc.begin: 1305 68, loc.end: 1307 43
free_text: type: "c", loc.begin: 1307 43, loc.end: 1307 51, text: "m&(m-1)"
inner_c_end: loc.begin: 1307 43, loc.end: 1307 51
free_text: type: "tex", loc.begin: 1307 51, loc.end: 1308 2, text: " is the same as
"
inner_c_begin: loc.begin: 1307 51, loc.end: 1308 2
free_text: type: "c", loc.begin: 1308 2, loc.end: 1308 4, text: "m"
inner_c_end: loc.begin: 1308 2, loc.end: 1308 4
tex_section_end: loc.begin: 1308 4, loc.end: 1310 3
tex_end: loc.begin: 1308 4, loc.end: 1310 3
c_begin: loc.begin: 1308 4, loc.end: 1310 3
named_section_begin: name: "Find and remove...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1310 3, loc.end: 1314 13, text: "    
mm=m&(m-1);
o,q=h->qsib;
k=m-mm;
if (mm) { "
comment_begin: type: "c", loc.begin: 1310 3, loc.end: 1314 13
free_text: type: "tex", loc.begin: 1314 13, loc.end: 1314 43, text: " there's more than one tree "
comment_end: type: "c", loc.begin: 1314 13, loc.end: 1314 43
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1323 6, loc.end: 1324 38, text: "while (mm);
  if (k+k<=m) oo,qq->qsib=q->qsib; "
comment_begin: type: "c", loc.begin: 1323 6, loc.end: 1324 38
free_text: type: "tex", loc.begin: 1324 38, loc.end: 1324 66, text: " remove the tree rooted at "
inner_c_begin: loc.begin: 1324 38, loc.end: 1324 66
free_text: type: "c", loc.begin: 1324 66, loc.end: 1324 68, text: "q"
inner_c_end: loc.begin: 1324 66, loc.end: 1324 68
free_text: type: "tex", loc.begin: 1324 68, loc.end: 1324 71, text: " "
comment_end: type: "c", loc.begin: 1324 68, loc.end: 1324 71
free_text: type: "c", loc.begin: 1324 71, loc.end: 1327 3, text: "
}

@ "
named_section_end: loc.begin: 1324 71, loc.end: 1327 3
c_end: loc.begin: 1324 71, loc.end: 1327 3
tex_begin: loc.begin: 1324 71, loc.end: 1327 3
tex_section_begin: type: "unstarred", loc.begin: 1324 71, loc.end: 1327 3
free_text: type: "tex", loc.begin: 1327 3, loc.end: 1329 63, text: "To complete our implementation, here is an algorithm that traverses
a binomial queue, ``visiting'' each node exactly once, destroying the
queue as it goes. The total number of mems required is about "
inner_c_begin: loc.begin: 1327 3, loc.end: 1329 63
free_text: type: "c", loc.begin: 1329 63, loc.end: 1329 69, text: "1.75m"
inner_c_end: loc.begin: 1329 63, loc.end: 1329 69
tex_section_end: loc.begin: 1329 69, loc.end: 1331 3
tex_end: loc.begin: 1329 69, loc.end: 1331 3
c_begin: loc.begin: 1329 69, loc.end: 1331 3
named_section_begin: name: "Prio...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1331 3, loc.end: 1333 13, text: "
qtraverse(h,visit)
  Arc *h; "
comment_begin: type: "c", loc.begin: 1331 3, loc.end: 1333 13
free_text: type: "tex", loc.begin: 1333 13, loc.end: 1333 55, text: " head of binomial queue to be unraveled "
comment_end: type: "c", loc.begin: 1333 13, loc.end: 1333 55
free_text: type: "c", loc.begin: 1334 12, loc.end: 1334 27, text: " (*visit)(); "
comment_begin: type: "c", loc.begin: 1334 12, loc.end: 1334 27
free_text: type: "tex", loc.begin: 1334 27, loc.end: 1334 67, text: " procedure to be invoked on each node "
comment_end: type: "c", loc.begin: 1334 27, loc.end: 1334 67
c_format: code: "@+"
free_text: type: "c", loc.begin: 1335 4, loc.end: 1335 23, text: "register long m; "
comment_begin: type: "c", loc.begin: 1335 4, loc.end: 1335 23
free_text: type: "tex", loc.begin: 1335 23, loc.end: 1335 56, text: " the number of nodes remaining "
comment_end: type: "c", loc.begin: 1335 23, loc.end: 1335 56
free_text: type: "c", loc.begin: 1335 56, loc.end: 1336 28, text: "
  register Arc *p,*q,*r; "
comment_begin: type: "c", loc.begin: 1335 56, loc.end: 1336 28
free_text: type: "tex", loc.begin: 1336 28, loc.end: 1336 74, text: " current position and neighboring positions "
comment_end: type: "c", loc.begin: 1336 28, loc.end: 1336 74
free_text: type: "c", loc.begin: 1336 74, loc.end: 1357 43, text: "
  o,m=h->qcount;
  p=h;
  while (m) {
    o,p=p->qsib;
    (*visit)(p);
    if (m&1) m--;
    else {
      o,q=p->qchild;
      if (m&2) (*visit)(q);
      else {
        o,r=q->qsib;
        if (m&(m-1)) oo,q->qsib=p->qsib;
        (*visit)(r);
        p=r;
      }
      m-=2;
    }
  }
}

@*"
named_section_end: loc.begin: 1336 74, loc.end: 1357 43
c_end: loc.begin: 1336 74, loc.end: 1357 43
tex_begin: loc.begin: 1336 74, loc.end: 1357 43
tex_section_begin: type: "starred", title: " Cheriton, Tarjan, and Karp's algorithm.", loc.begin: 1336 74, loc.end: 1357 43
index_entry: entry: "Karp, Richard Manning", loc.begin: 1357 43, loc.end: 1375 26
index_entry: entry: "Tarjan, Robert Endre", loc.begin: 1375 26, loc.end: 1376 25
tex_section_end: loc.begin: 1376 25, loc.end: 1384 3
tex_end: loc.begin: 1376 25, loc.end: 1384 3
c_begin: loc.begin: 1376 25, loc.end: 1384 3
named_section_begin: name: "Sub...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
section_name: name: "Local variables for |cher_tar_kar|", isPrefix: loc.begin: 1387 4, loc.end: 1387 6, false
c_format: code: "@;"
c_format: code: "@#"
section_name: name: "Do stage 1 of |cher_tar_kar|", isPrefix: loc.begin: 1387 10, loc.end: 1389 5, false
free_text: type: "c", loc.begin: 1389 5, loc.end: 1390 24, text: ";
  if (verbose) printf("
string_begin: type: "c", loc.begin: 1389 5, loc.end: 1390 24
free_text: type: "tex", loc.begin: 1390 24, loc.end: 1390 58, text: "    [Stage 1 has used %ld mems]\n"
string_end: type: "c", loc.begin: 1390 24, loc.end: 1390 58
section_name: name: "Do stage 2 of |cher_tar_kar|", isPrefix: loc.begin: 1390 58, loc.end: 1391 5, false
free_text: type: "c", loc.begin: 1391 5, loc.end: 1395 3, text: ";
  return tot_len;
}

@ "
named_section_end: loc.begin: 1391 5, loc.end: 1395 3
c_end: loc.begin: 1391 5, loc.end: 1395 3
tex_begin: loc.begin: 1391 5, loc.end: 1395 3
tex_section_begin: type: "unstarred", loc.begin: 1391 5, loc.end: 1395 3
tex_section_end: loc.begin: 1395 3, loc.end: 1408 3
tex_end: loc.begin: 1395 3, loc.end: 1408 3
c_begin: loc.begin: 1395 3, loc.end: 1408 3
named_section_begin: name: "Local variables for |ch...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1408 3, loc.end: 1409 26, text: "
register Vertex *s,*t; "
comment_begin: type: "c", loc.begin: 1408 3, loc.end: 1409 26
free_text: type: "tex", loc.begin: 1409 26, loc.end: 1409 65, text: " beginning and end of the small list "
comment_end: type: "c", loc.begin: 1409 26, loc.end: 1409 65
free_text: type: "c", loc.begin: 1409 65, loc.end: 1410 23, text: "
Vertex *large_list; "
comment_begin: type: "c", loc.begin: 1409 65, loc.end: 1410 23
free_text: type: "tex", loc.begin: 1410 23, loc.end: 1410 67, text: " beginning of the list of large fragments "
comment_end: type: "c", loc.begin: 1410 23, loc.end: 1410 67
free_text: type: "c", loc.begin: 1410 67, loc.end: 1411 15, text: "
long frags; "
comment_begin: type: "c", loc.begin: 1410 67, loc.end: 1411 15
free_text: type: "tex", loc.begin: 1411 15, loc.end: 1411 63, text: " current number of fragments, large and small "
comment_end: type: "c", loc.begin: 1411 15, loc.end: 1411 63
free_text: type: "c", loc.begin: 1411 63, loc.end: 1412 28, text: "
unsigned long tot_len=0; "
comment_begin: type: "c", loc.begin: 1411 63, loc.end: 1412 28
free_text: type: "tex", loc.begin: 1412 28, loc.end: 1412 70, text: " total length of all edges in fragments "
comment_end: type: "c", loc.begin: 1412 28, loc.end: 1412 70
free_text: type: "c", loc.begin: 1412 70, loc.end: 1413 26, text: "
register Vertex *u,*v; "
comment_begin: type: "c", loc.begin: 1412 70, loc.end: 1413 26
free_text: type: "tex", loc.begin: 1413 26, loc.end: 1413 61, text: " registers for list manipulation "
comment_end: type: "c", loc.begin: 1413 26, loc.end: 1413 61
free_text: type: "c", loc.begin: 1413 61, loc.end: 1414 20, text: "
register Arc *a; "
comment_begin: type: "c", loc.begin: 1413 61, loc.end: 1414 20
free_text: type: "tex", loc.begin: 1414 20, loc.end: 1414 35, text: " and another "
comment_end: type: "c", loc.begin: 1414 20, loc.end: 1414 35
free_text: type: "c", loc.begin: 1414 35, loc.end: 1415 22, text: "
register long j,k; "
comment_begin: type: "c", loc.begin: 1414 35, loc.end: 1415 22
free_text: type: "tex", loc.begin: 1415 22, loc.end: 1415 53, text: " index registers for stage 2 "
comment_end: type: "c", loc.begin: 1415 22, loc.end: 1415 53
free_text: type: "c", loc.begin: 1415 53, loc.end: 1417 3, text: "

@ "
named_section_end: loc.begin: 1415 53, loc.end: 1417 3
c_end: loc.begin: 1415 53, loc.end: 1417 3
tex_begin: loc.begin: 1415 53, loc.end: 1417 3
tex_section_begin: type: "unstarred", loc.begin: 1415 53, loc.end: 1417 3
free_text: type: "tex", loc.begin: 1417 3, loc.end: 1417 20, text: "We need to make "
inner_c_begin: loc.begin: 1417 3, loc.end: 1417 20
free_text: type: "c", loc.begin: 1417 20, loc.end: 1417 28, text: "lo_sqrt"
inner_c_end: loc.begin: 1417 20, loc.end: 1417 28
free_text: type: "tex", loc.begin: 1417 28, loc.end: 1417 49, text: " global so that the "
inner_c_begin: loc.begin: 1417 28, loc.end: 1417 49
free_text: type: "c", loc.begin: 1417 49, loc.end: 1417 59, text: "note_edge"
inner_c_end: loc.begin: 1417 49, loc.end: 1417 59
tex_section_end: loc.begin: 1417 59, loc.end: 1420 3
tex_end: loc.begin: 1417 59, loc.end: 1420 3
c_begin: loc.begin: 1417 59, loc.end: 1420 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1420 3, loc.end: 1421 25, text: "
long lo_sqrt,hi_sqrt; "
comment_begin: type: "c", loc.begin: 1420 3, loc.end: 1421 25
free_text: type: "tex", loc.begin: 1421 25, loc.end: 1421 50, text: " \lsqrtn\ and \usqrtn\ "
comment_end: type: "c", loc.begin: 1421 25, loc.end: 1421 50
free_text: type: "c", loc.begin: 1421 50, loc.end: 1423 3, text: "

@ "
named_section_end: loc.begin: 1421 50, loc.end: 1423 3
c_end: loc.begin: 1421 50, loc.end: 1423 3
tex_begin: loc.begin: 1421 50, loc.end: 1423 3
tex_section_begin: type: "unstarred", loc.begin: 1421 50, loc.end: 1423 3
free_text: type: "tex", loc.begin: 1423 3, loc.end: 1425 30, text: "There is a nonobvious way to compute \usqrtn\ and \lsqrtn. Since
$\sqrt n$ is small and arithmetic is mem-free, the author
couldn't resist writing the "
inner_c_begin: loc.begin: 1423 3, loc.end: 1425 30
free_text: type: "c", loc.begin: 1425 30, loc.end: 1425 34, text: "for"
inner_c_end: loc.begin: 1425 30, loc.end: 1425 34
index_entry: entry: "discussion of \\{mems}", loc.begin: 1425 34, loc.end: 1429 27
tex_section_end: loc.begin: 1429 27, loc.end: 1431 3
tex_end: loc.begin: 1429 27, loc.end: 1431 3
c_begin: loc.begin: 1429 27, loc.end: 1431 3
named_section_begin: name: "Do stage 1 of |cher_tar_kar|", isPrefix: false, isContinuation: "false"
section_name: name: "Create the small list", isPrefix: loc.begin: 1431 3, loc.end: 1437 3, false
section_name: name: "Combine the first fragment on the small list with its nearest neighbor", isPrefix: loc.begin: 1437 3, loc.end: 1439 5, false
free_text: type: "c", loc.begin: 1439 5, loc.end: 1443 3, text: ";
  frags--;
}

@ "
named_section_end: loc.begin: 1439 5, loc.end: 1443 3
c_end: loc.begin: 1439 5, loc.end: 1443 3
tex_begin: loc.begin: 1439 5, loc.end: 1443 3
tex_section_begin: type: "unstarred", loc.begin: 1439 5, loc.end: 1443 3
free_text: type: "tex", loc.begin: 1443 3, loc.end: 1444 21, text: "To represent fragments, we will use several utility fields already
defined above. The "
inner_c_begin: loc.begin: 1443 3, loc.end: 1444 21
free_text: type: "c", loc.begin: 1444 21, loc.end: 1444 26, text: "lsib"
inner_c_end: loc.begin: 1444 21, loc.end: 1444 26
free_text: type: "tex", loc.begin: 1444 26, loc.end: 1444 32, text: " and "
inner_c_begin: loc.begin: 1444 26, loc.end: 1444 32
free_text: type: "c", loc.begin: 1444 32, loc.end: 1444 37, text: "rsib"
inner_c_end: loc.begin: 1444 32, loc.end: 1444 37
free_text: type: "tex", loc.begin: 1444 37, loc.end: 1445 45, text: " pointers are used between fragments
in the small list, which is doubly linked; "
inner_c_begin: loc.begin: 1444 37, loc.end: 1445 45
free_text: type: "c", loc.begin: 1445 45, loc.end: 1445 47, text: "s"
inner_c_end: loc.begin: 1445 45, loc.end: 1445 47
free_text: type: "tex", loc.begin: 1445 47, loc.end: 1446 12, text: "~points to the first small
fragment, "
inner_c_begin: loc.begin: 1445 47, loc.end: 1446 12
free_text: type: "c", loc.begin: 1446 12, loc.end: 1446 20, text: "s->rsib"
inner_c_end: loc.begin: 1446 12, loc.end: 1446 20
free_text: type: "tex", loc.begin: 1446 20, loc.end: 1446 42, text: " to the next, \dots, "
inner_c_begin: loc.begin: 1446 20, loc.end: 1446 42
free_text: type: "c", loc.begin: 1446 42, loc.end: 1446 50, text: "t->lsib"
inner_c_end: loc.begin: 1446 42, loc.end: 1446 50
free_text: type: "tex", loc.begin: 1446 50, loc.end: 1447 6, text: " to the second-from-last,
and "
inner_c_begin: loc.begin: 1446 50, loc.end: 1447 6
free_text: type: "c", loc.begin: 1447 6, loc.end: 1447 8, text: "t"
inner_c_end: loc.begin: 1447 6, loc.end: 1447 8
free_text: type: "tex", loc.begin: 1447 8, loc.end: 1447 42, text: " to the last. The pointer fields "
inner_c_begin: loc.begin: 1447 8, loc.end: 1447 42
free_text: type: "c", loc.begin: 1447 42, loc.end: 1447 50, text: "s->lsib"
inner_c_end: loc.begin: 1447 42, loc.end: 1447 50
free_text: type: "tex", loc.begin: 1447 50, loc.end: 1447 56, text: " and "
inner_c_begin: loc.begin: 1447 50, loc.end: 1447 56
free_text: type: "c", loc.begin: 1447 56, loc.end: 1447 64, text: "t->rsib"
inner_c_end: loc.begin: 1447 56, loc.end: 1447 64
free_text: type: "tex", loc.begin: 1447 64, loc.end: 1448 17, text: " are
undefined. The "
inner_c_begin: loc.begin: 1447 64, loc.end: 1448 17
free_text: type: "c", loc.begin: 1448 17, loc.end: 1448 28, text: "large_list"
inner_c_end: loc.begin: 1448 17, loc.end: 1448 28
free_text: type: "tex", loc.begin: 1448 28, loc.end: 1448 51, text: " is singly linked via "
inner_c_begin: loc.begin: 1448 28, loc.end: 1448 51
free_text: type: "c", loc.begin: 1448 51, loc.end: 1448 56, text: "rsib"
inner_c_end: loc.begin: 1448 51, loc.end: 1448 56
free_text: type: "tex", loc.begin: 1448 56, loc.end: 1449 19, text: " pointers,
terminating with "
inner_c_begin: loc.begin: 1448 56, loc.end: 1449 19
free_text: type: "c", loc.begin: 1449 19, loc.end: 1449 24, text: "NULL"
inner_c_end: loc.begin: 1449 19, loc.end: 1449 24
free_text: type: "tex", loc.begin: 1449 24, loc.end: 1451 6, text: ".

The "
inner_c_begin: loc.begin: 1449 24, loc.end: 1451 6
free_text: type: "c", loc.begin: 1451 6, loc.end: 1451 12, text: "csize"
inner_c_end: loc.begin: 1451 6, loc.end: 1451 12
free_text: type: "tex", loc.begin: 1451 12, loc.end: 1453 6, text: " field of each fragment tells how many vertices it contains.

The "
inner_c_begin: loc.begin: 1451 12, loc.end: 1453 6
free_text: type: "c", loc.begin: 1453 6, loc.end: 1453 11, text: "comp"
inner_c_end: loc.begin: 1453 6, loc.end: 1453 11
free_text: type: "tex", loc.begin: 1453 11, loc.end: 1453 37, text: " field of each vertex is "
inner_c_begin: loc.begin: 1453 11, loc.end: 1453 37
free_text: type: "c", loc.begin: 1453 37, loc.end: 1453 42, text: "NULL"
inner_c_end: loc.begin: 1453 37, loc.end: 1453 42
free_text: type: "tex", loc.begin: 1453 42, loc.end: 1454 57, text: " if this vertex represents a
fragment (i.e., if this vertex is in the small list or "
inner_c_begin: loc.begin: 1453 42, loc.end: 1454 57
free_text: type: "c", loc.begin: 1454 57, loc.end: 1454 68, text: "large_list"
inner_c_end: loc.begin: 1454 57, loc.end: 1454 68
free_text: type: "tex", loc.begin: 1454 68, loc.end: 1458 15, text: ");
otherwise it points to another vertex that is closer to the fragment
representative.

Finally, the "
inner_c_begin: loc.begin: 1454 68, loc.end: 1458 15
free_text: type: "c", loc.begin: 1458 15, loc.end: 1458 18, text: "pq"
inner_c_end: loc.begin: 1458 15, loc.end: 1458 18
free_text: type: "tex", loc.begin: 1458 18, loc.end: 1461 35, text: " pointer of each fragment points to the header node of
its priority queue, which is a binomial queue containing all
unlooked-at arcs that originate from vertices in the fragment.
This pointer is identical to the "
inner_c_begin: loc.begin: 1458 18, loc.end: 1461 35
free_text: type: "c", loc.begin: 1461 35, loc.end: 1461 42, text: "newarc"
inner_c_end: loc.begin: 1461 35, loc.end: 1461 42
free_text: type: "tex", loc.begin: 1461 42, loc.end: 1462 51, text: " pointer already set up.
In a production implementation, we wouldn't need "
inner_c_begin: loc.begin: 1461 42, loc.end: 1462 51
free_text: type: "c", loc.begin: 1462 51, loc.end: 1462 54, text: "pq"
inner_c_end: loc.begin: 1462 51, loc.end: 1462 54
index_entry: entry: "discussion of \\{mems}", loc.begin: 1462 54, loc.end: 1465 27
tex_section_end: loc.begin: 1465 27, loc.end: 1467 3
tex_end: loc.begin: 1465 27, loc.end: 1467 3
middle_begin: loc.begin: 1465 27, loc.end: 1467 3
macro_begin: name: "pq", params: {}, loc.begin: 1467 3, loc.end: 1469 3, text: "pq "
macro_end: loc.begin: 1467 3, loc.end: 1469 3
middle_end: loc.begin: 1467 3, loc.end: 1469 3
c_begin: loc.begin: 1467 3, loc.end: 1469 3
named_section_begin: name: "Create the small...", isPrefix: true, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1473 21, loc.end: 1477 24, text: "o,(v-1)->rsib=v;
  }
  o,v->comp=NULL;
  o,v->csize=1;
  o,v->pq->qcount=0; "
comment_begin: type: "c", loc.begin: 1473 21, loc.end: 1477 24
free_text: type: "tex", loc.begin: 1477 24, loc.end: 1477 65, text: " the binomial queue is initially empty "
comment_end: type: "c", loc.begin: 1477 24, loc.end: 1477 65
free_text: type: "c", loc.begin: 1477 65, loc.end: 1482 3, text: "
  for (o,a=v->arcs;a;o,a=a->next) qenque(v->pq,a);
}
t=v-1;

@ "
named_section_end: loc.begin: 1477 65, loc.end: 1482 3
c_end: loc.begin: 1477 65, loc.end: 1482 3
tex_begin: loc.begin: 1477 65, loc.end: 1482 3
tex_section_begin: type: "unstarred", loc.begin: 1477 65, loc.end: 1482 3
tex_section_end: loc.begin: 1482 3, loc.end: 1482 5
tex_end: loc.begin: 1482 3, loc.end: 1482 5
c_begin: loc.begin: 1482 3, loc.end: 1482 5
named_section_begin: name: "Combine the first fragment...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1482 5, loc.end: 1484 16, text: "
v=s;
o,s=s->rsib; "
comment_begin: type: "c", loc.begin: 1482 5, loc.end: 1484 16
free_text: type: "tex", loc.begin: 1484 16, loc.end: 1484 25, text: " remove "
inner_c_begin: loc.begin: 1484 16, loc.end: 1484 25
free_text: type: "c", loc.begin: 1484 25, loc.end: 1484 27, text: "v"
inner_c_end: loc.begin: 1484 25, loc.end: 1484 27
free_text: type: "tex", loc.begin: 1484 27, loc.end: 1484 46, text: " from small list "
comment_end: type: "c", loc.begin: 1484 27, loc.end: 1484 46
c_format: code: "@+"
free_text: type: "c", loc.begin: 1485 5, loc.end: 1486 35, text: "{a=qdel_min(v->pq);
  if (a==NULL) return INFINITY; "
comment_begin: type: "c", loc.begin: 1485 5, loc.end: 1486 35
free_text: type: "tex", loc.begin: 1486 35, loc.end: 1486 64, text: " the graph isn't connected "
comment_end: type: "c", loc.begin: 1486 35, loc.end: 1486 64
free_text: type: "c", loc.begin: 1486 64, loc.end: 1488 34, text: "
  o,u=a->tip;
  while (o,u->comp) u=u->comp; "
comment_begin: type: "c", loc.begin: 1486 64, loc.end: 1488 34
free_text: type: "tex", loc.begin: 1488 34, loc.end: 1488 66, text: " find the fragment pointed to "
comment_end: type: "c", loc.begin: 1488 34, loc.end: 1488 66
c_format: code: "@+"
free_text: type: "c", loc.begin: 1489 4, loc.end: 1489 20, text: "while (u==v); "
comment_begin: type: "c", loc.begin: 1489 4, loc.end: 1489 20
free_text: type: "tex", loc.begin: 1489 20, loc.end: 1489 60, text: " repeat until a new fragment is found "
comment_end: type: "c", loc.begin: 1489 20, loc.end: 1489 60
section_name: name: "Report the new edge verbosely", isPrefix: loc.begin: 1489 60, loc.end: 1490 16, false
section_name: name: "Move |u| to the proper list position", isPrefix: loc.begin: 1490 16, loc.end: 1497 3, false
free_text: type: "c", loc.begin: 1497 3, loc.end: 1499 3, text: ";

@ "
named_section_end: loc.begin: 1497 3, loc.end: 1499 3
c_end: loc.begin: 1497 3, loc.end: 1499 3
tex_begin: loc.begin: 1497 3, loc.end: 1499 3
tex_section_begin: type: "unstarred", loc.begin: 1497 3, loc.end: 1499 3
tex_section_end: loc.begin: 1499 3, loc.end: 1499 5
tex_end: loc.begin: 1499 3, loc.end: 1499 5
c_begin: loc.begin: 1499 3, loc.end: 1499 5
named_section_begin: name: "Local variables for |cher...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1499 5, loc.end: 1500 27, text: "
long old_size,new_size; "
comment_begin: type: "c", loc.begin: 1499 5, loc.end: 1500 27
free_text: type: "tex", loc.begin: 1500 27, loc.end: 1500 46, text: " size of fragment "
inner_c_begin: loc.begin: 1500 27, loc.end: 1500 46
free_text: type: "c", loc.begin: 1500 46, loc.end: 1500 48, text: "u"
inner_c_end: loc.begin: 1500 46, loc.end: 1500 48
free_text: type: "tex", loc.begin: 1500 48, loc.end: 1500 69, text: ", before and after "
comment_end: type: "c", loc.begin: 1500 48, loc.end: 1500 69
free_text: type: "c", loc.begin: 1500 69, loc.end: 1502 3, text: "

@ "
named_section_end: loc.begin: 1500 69, loc.end: 1502 3
c_end: loc.begin: 1500 69, loc.end: 1502 3
tex_begin: loc.begin: 1500 69, loc.end: 1502 3
tex_section_begin: type: "unstarred", loc.begin: 1500 69, loc.end: 1502 3
free_text: type: "tex", loc.begin: 1502 3, loc.end: 1503 11, text: "Here is a fussy part of the program. We have just merged the small
fragment "
inner_c_begin: loc.begin: 1502 3, loc.end: 1503 11
free_text: type: "c", loc.begin: 1503 11, loc.end: 1503 13, text: "v"
inner_c_end: loc.begin: 1503 11, loc.end: 1503 13
free_text: type: "tex", loc.begin: 1503 13, loc.end: 1503 37, text: " into another fragment~"
inner_c_begin: loc.begin: 1503 13, loc.end: 1503 37
free_text: type: "c", loc.begin: 1503 37, loc.end: 1503 39, text: "u"
inner_c_end: loc.begin: 1503 37, loc.end: 1503 39
free_text: type: "tex", loc.begin: 1503 39, loc.end: 1503 45, text: ". If "
inner_c_begin: loc.begin: 1503 39, loc.end: 1503 45
free_text: type: "c", loc.begin: 1503 45, loc.end: 1503 47, text: "u"
inner_c_end: loc.begin: 1503 45, loc.end: 1503 47
free_text: type: "tex", loc.begin: 1503 47, loc.end: 1505 43, text: " was already large,
there's nothing to do (except to check if the small list has just
become empty). Otherwise we need to move "
inner_c_begin: loc.begin: 1503 47, loc.end: 1505 43
free_text: type: "c", loc.begin: 1505 43, loc.end: 1505 45, text: "u"
inner_c_end: loc.begin: 1505 43, loc.end: 1505 45
tex_section_end: loc.begin: 1505 45, loc.end: 1510 3
tex_end: loc.begin: 1505 45, loc.end: 1510 3
c_begin: loc.begin: 1505 45, loc.end: 1510 3
named_section_begin: name: "Move |u|...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1510 3, loc.end: 1511 28, text: "
if (old_size>=hi_sqrt) { "
comment_begin: type: "c", loc.begin: 1510 3, loc.end: 1511 28
free_text: type: "tex", loc.begin: 1511 28, loc.end: 1511 30, text: " "
inner_c_begin: loc.begin: 1511 28, loc.end: 1511 30
free_text: type: "c", loc.begin: 1511 30, loc.end: 1511 32, text: "u"
inner_c_end: loc.begin: 1511 30, loc.end: 1511 32
free_text: type: "tex", loc.begin: 1511 32, loc.end: 1511 45, text: " was large "
comment_end: type: "c", loc.begin: 1511 32, loc.end: 1511 45
free_text: type: "c", loc.begin: 1511 45, loc.end: 1512 23, text: "
  if (t==v) s=NULL; "
comment_begin: type: "c", loc.begin: 1511 45, loc.end: 1512 23
free_text: type: "tex", loc.begin: 1512 23, loc.end: 1512 55, text: " small list just became empty "
comment_end: type: "c", loc.begin: 1512 23, loc.end: 1512 55
c_format: code: "@+"
free_text: type: "c", loc.begin: 1513 4, loc.end: 1513 35, text: "else if (new_size<hi_sqrt) { "
comment_begin: type: "c", loc.begin: 1513 4, loc.end: 1513 35
free_text: type: "tex", loc.begin: 1513 35, loc.end: 1513 37, text: " "
inner_c_begin: loc.begin: 1513 35, loc.end: 1513 37
free_text: type: "c", loc.begin: 1513 37, loc.end: 1513 39, text: "u"
inner_c_end: loc.begin: 1513 37, loc.end: 1513 39
free_text: type: "tex", loc.begin: 1513 39, loc.end: 1513 65, text: " was and still is small "
comment_end: type: "c", loc.begin: 1513 39, loc.end: 1513 65
free_text: type: "c", loc.begin: 1513 65, loc.end: 1514 25, text: "
  if (u==t) goto fin; "
comment_begin: type: "c", loc.begin: 1513 65, loc.end: 1514 25
free_text: type: "tex", loc.begin: 1514 25, loc.end: 1514 27, text: " "
inner_c_begin: loc.begin: 1514 25, loc.end: 1514 27
free_text: type: "c", loc.begin: 1514 27, loc.end: 1514 29, text: "u"
inner_c_end: loc.begin: 1514 27, loc.end: 1514 29
free_text: type: "tex", loc.begin: 1514 29, loc.end: 1514 60, text: " is already where we want it "
comment_end: type: "c", loc.begin: 1514 29, loc.end: 1514 60
free_text: type: "c", loc.begin: 1514 60, loc.end: 1515 28, text: "
  if (u==s) o,s=u->rsib; "
comment_begin: type: "c", loc.begin: 1514 60, loc.end: 1515 28
free_text: type: "tex", loc.begin: 1515 28, loc.end: 1515 37, text: " remove "
inner_c_begin: loc.begin: 1515 28, loc.end: 1515 37
free_text: type: "c", loc.begin: 1515 37, loc.end: 1515 39, text: "u"
inner_c_end: loc.begin: 1515 37, loc.end: 1515 39
free_text: type: "tex", loc.begin: 1515 39, loc.end: 1515 53, text: " from front "
comment_end: type: "c", loc.begin: 1515 39, loc.end: 1515 53
free_text: type: "c", loc.begin: 1515 53, loc.end: 1517 34, text: "
  else {
    ooo,u->rsib->lsib=u->lsib; "
comment_begin: type: "c", loc.begin: 1515 53, loc.end: 1517 34
free_text: type: "tex", loc.begin: 1517 34, loc.end: 1517 43, text: " detach "
inner_c_begin: loc.begin: 1517 34, loc.end: 1517 43
free_text: type: "c", loc.begin: 1517 43, loc.end: 1517 45, text: "u"
inner_c_end: loc.begin: 1517 43, loc.end: 1517 45
free_text: type: "tex", loc.begin: 1517 45, loc.end: 1517 60, text: " from middle "
comment_end: type: "c", loc.begin: 1517 45, loc.end: 1517 60
free_text: type: "c", loc.begin: 1517 60, loc.end: 1518 32, text: "
    o,u->lsib->rsib=u->rsib; "
comment_begin: type: "c", loc.begin: 1517 60, loc.end: 1518 32
free_text: type: "tex", loc.begin: 1518 32, loc.end: 1518 72, text: " do you follow the mem-counting here? "
comment_end: type: "c", loc.begin: 1518 32, loc.end: 1518 72
index_entry: entry: "discussion of \\{mems}", loc.begin: 1518 72, loc.end: 1519 27
free_text: type: "c", loc.begin: 1519 27, loc.end: 1521 18, text: "
  }
  o,t->rsib=u; "
comment_begin: type: "c", loc.begin: 1519 27, loc.end: 1521 18
free_text: type: "tex", loc.begin: 1521 18, loc.end: 1521 27, text: " insert "
inner_c_begin: loc.begin: 1521 18, loc.end: 1521 27
free_text: type: "c", loc.begin: 1521 27, loc.end: 1521 29, text: "u"
inner_c_end: loc.begin: 1521 27, loc.end: 1521 29
free_text: type: "tex", loc.begin: 1521 29, loc.end: 1521 43, text: " at the end "
comment_end: type: "c", loc.begin: 1521 29, loc.end: 1521 43
c_format: code: "@+"
free_text: type: "c", loc.begin: 1524 4, loc.end: 1524 13, text: "else { "
comment_begin: type: "c", loc.begin: 1524 4, loc.end: 1524 13
free_text: type: "tex", loc.begin: 1524 13, loc.end: 1524 15, text: " "
inner_c_begin: loc.begin: 1524 13, loc.end: 1524 15
free_text: type: "c", loc.begin: 1524 15, loc.end: 1524 17, text: "u"
inner_c_end: loc.begin: 1524 15, loc.end: 1524 17
free_text: type: "tex", loc.begin: 1524 17, loc.end: 1524 42, text: " has just become large "
comment_end: type: "c", loc.begin: 1524 17, loc.end: 1524 42
free_text: type: "c", loc.begin: 1524 42, loc.end: 1526 27, text: "
  if (u==t) {
    if (u==s) goto fin; "
comment_begin: type: "c", loc.begin: 1524 42, loc.end: 1526 27
free_text: type: "tex", loc.begin: 1526 27, loc.end: 1526 69, text: " well, keep it small, we're done anyway "
comment_end: type: "c", loc.begin: 1526 27, loc.end: 1526 69
free_text: type: "c", loc.begin: 1526 69, loc.end: 1527 20, text: "
    o,t=u->lsib; "
comment_begin: type: "c", loc.begin: 1526 69, loc.end: 1527 20
free_text: type: "tex", loc.begin: 1527 20, loc.end: 1527 29, text: " remove "
inner_c_begin: loc.begin: 1527 20, loc.end: 1527 29
free_text: type: "c", loc.begin: 1527 29, loc.end: 1527 31, text: "u"
inner_c_end: loc.begin: 1527 29, loc.end: 1527 31
free_text: type: "tex", loc.begin: 1527 31, loc.end: 1527 43, text: " from end "
comment_end: type: "c", loc.begin: 1527 31, loc.end: 1527 43
c_format: code: "@+"
free_text: type: "c", loc.begin: 1528 6, loc.end: 1529 20, text: "else if (u==s)
    o,s=u->rsib; "
comment_begin: type: "c", loc.begin: 1528 6, loc.end: 1529 20
free_text: type: "tex", loc.begin: 1529 20, loc.end: 1529 29, text: " remove "
inner_c_begin: loc.begin: 1529 20, loc.end: 1529 29
free_text: type: "c", loc.begin: 1529 29, loc.end: 1529 31, text: "u"
inner_c_end: loc.begin: 1529 29, loc.end: 1529 31
free_text: type: "tex", loc.begin: 1529 31, loc.end: 1529 45, text: " from front "
comment_end: type: "c", loc.begin: 1529 31, loc.end: 1529 45
free_text: type: "c", loc.begin: 1529 45, loc.end: 1531 34, text: "
  else {
    ooo,u->rsib->lsib=u->lsib; "
comment_begin: type: "c", loc.begin: 1529 45, loc.end: 1531 34
free_text: type: "tex", loc.begin: 1531 34, loc.end: 1531 43, text: " detach "
inner_c_begin: loc.begin: 1531 34, loc.end: 1531 43
free_text: type: "c", loc.begin: 1531 43, loc.end: 1531 45, text: "u"
inner_c_end: loc.begin: 1531 43, loc.end: 1531 45
free_text: type: "tex", loc.begin: 1531 45, loc.end: 1531 60, text: " from middle "
comment_end: type: "c", loc.begin: 1531 45, loc.end: 1531 60
c_format: code: "@+"
free_text: type: "c", loc.begin: 1534 26, loc.end: 1534 42, text: "large_list=u; "
comment_begin: type: "c", loc.begin: 1534 26, loc.end: 1534 42
free_text: type: "tex", loc.begin: 1534 42, loc.end: 1534 49, text: " make "
inner_c_begin: loc.begin: 1534 42, loc.end: 1534 49
free_text: type: "c", loc.begin: 1534 49, loc.end: 1534 51, text: "u"
inner_c_end: loc.begin: 1534 49, loc.end: 1534 51
free_text: type: "tex", loc.begin: 1534 51, loc.end: 1534 60, text: " large "
comment_end: type: "c", loc.begin: 1534 51, loc.end: 1534 60
free_text: type: "c", loc.begin: 1534 60, loc.end: 1538 3, text: "
}
fin:;

@ "
named_section_end: loc.begin: 1534 60, loc.end: 1538 3
c_end: loc.begin: 1534 60, loc.end: 1538 3
tex_begin: loc.begin: 1534 60, loc.end: 1538 3
tex_section_begin: type: "unstarred", loc.begin: 1534 60, loc.end: 1538 3
free_text: type: "tex", loc.begin: 1538 3, loc.end: 1540 20, text: "We don't have room in our binomial queues to keep track of both
endpoints of the arcs. But the arcs occur in pairs, and by looking
at the address of "
inner_c_begin: loc.begin: 1538 3, loc.end: 1540 20
free_text: type: "c", loc.begin: 1540 20, loc.end: 1540 22, text: "a"
inner_c_end: loc.begin: 1540 20, loc.end: 1540 22
free_text: type: "tex", loc.begin: 1540 22, loc.end: 1541 2, text: " we can tell whether the matching arc is
"
inner_c_begin: loc.begin: 1540 22, loc.end: 1541 2
free_text: type: "c", loc.begin: 1541 2, loc.end: 1541 6, text: "a+1"
inner_c_end: loc.begin: 1541 2, loc.end: 1541 6
free_text: type: "tex", loc.begin: 1541 6, loc.end: 1541 11, text: " or "
inner_c_begin: loc.begin: 1541 6, loc.end: 1541 11
free_text: type: "c", loc.begin: 1541 11, loc.end: 1541 15, text: "a-1"
inner_c_end: loc.begin: 1541 11, loc.end: 1541 15
tex_section_end: loc.begin: 1541 15, loc.end: 1543 3
tex_end: loc.begin: 1541 15, loc.end: 1543 3
c_begin: loc.begin: 1541 15, loc.end: 1543 3
named_section_begin: name: "Report the new edge verbosely", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 1543 3, loc.end: 1546 54, text: "
report((edge_trick&(siz_t)a? a-1: a+1)->tip,a->tip,a->len);

@*"
named_section_end: loc.begin: 1543 3, loc.end: 1546 54
c_end: loc.begin: 1543 3, loc.end: 1546 54
tex_begin: loc.begin: 1543 3, loc.end: 1546 54
tex_section_begin: type: "starred", title: "Cheriton, Tarjan, and Karp's algorithm (continued).", loc.begin: 1543 3, loc.end: 1546 54
free_text: type: "tex", loc.begin: 1546 54, loc.end: 1549 37, text: "
And now for the second part of the algorithm. Here we need to
find room for a $\lsqrtn\times\lsqrtn$ matrix of edge lengths;
we will use random access into the "
inner_c_begin: loc.begin: 1546 54, loc.end: 1549 37
free_text: type: "c", loc.begin: 1549 37, loc.end: 1549 39, text: "z"
inner_c_end: loc.begin: 1549 37, loc.end: 1549 39
free_text: type: "tex", loc.begin: 1549 39, loc.end: 1550 52, text: " utility fields of vertex records,
since these haven't been used for anything yet by "
inner_c_begin: loc.begin: 1549 39, loc.end: 1550 52
free_text: type: "c", loc.begin: 1550 52, loc.end: 1550 65, text: "cher_tar_kar"
inner_c_end: loc.begin: 1550 52, loc.end: 1550 65
free_text: type: "tex", loc.begin: 1550 65, loc.end: 1551 22, text: ".
We can also use the "
inner_c_begin: loc.begin: 1550 65, loc.end: 1551 22
free_text: type: "c", loc.begin: 1551 22, loc.end: 1551 24, text: "v"
inner_c_end: loc.begin: 1551 22, loc.end: 1551 24
free_text: type: "tex", loc.begin: 1551 24, loc.end: 1552 57, text: " utility fields to record the arcs that
are the source of the best lengths, since this was the "
inner_c_begin: loc.begin: 1551 24, loc.end: 1552 57
free_text: type: "c", loc.begin: 1552 57, loc.end: 1552 62, text: "lsib"
inner_c_end: loc.begin: 1552 57, loc.end: 1552 62
free_text: type: "tex", loc.begin: 1552 62, loc.end: 1557 2, text: "
field (no longer needed). The program doesn't count mems for
updating that field, since it considers its goal to be simply
the calculation of minimum spanning tree length; the actual
edges of the minimum spanning tree are computed only for
"
inner_c_begin: loc.begin: 1552 62, loc.end: 1557 2
free_text: type: "c", loc.begin: 1557 2, loc.end: 1557 10, text: "verbose"
inner_c_end: loc.begin: 1557 2, loc.end: 1557 10
free_text: type: "tex", loc.begin: 1557 10, loc.end: 1557 50, text: " mode. (We want to see how competitive "
inner_c_begin: loc.begin: 1557 10, loc.end: 1557 50
free_text: type: "c", loc.begin: 1557 50, loc.end: 1557 63, text: "cher_tar_kar"
inner_c_end: loc.begin: 1557 50, loc.end: 1557 63
index_entry: entry: "discussion of \\{mems}", loc.begin: 1557 63, loc.end: 1559 27
free_text: type: "tex", loc.begin: 1559 27, loc.end: 1562 53, text: "

In stage 2, the vertices will be assigned integer index numbers
between 0 and $\lsqrtn-1$. We'll put this into the "
inner_c_begin: loc.begin: 1559 27, loc.end: 1562 53
free_text: type: "c", loc.begin: 1562 53, loc.end: 1562 59, text: "csize"
inner_c_end: loc.begin: 1562 53, loc.end: 1562 59
free_text: type: "tex", loc.begin: 1562 59, loc.end: 1563 41, text: " field,
which is no longer needed, and call it "
inner_c_begin: loc.begin: 1562 59, loc.end: 1563 41
free_text: type: "c", loc.begin: 1563 41, loc.end: 1563 48, text: "findex"
inner_c_end: loc.begin: 1563 41, loc.end: 1563 48
tex_section_end: loc.begin: 1563 48, loc.end: 1565 3
tex_end: loc.begin: 1563 48, loc.end: 1565 3
middle_begin: loc.begin: 1563 48, loc.end: 1565 3
macro_begin: name: "findex", params: {}, loc.begin: 1565 3, loc.end: 1566 3, text: "findex "
macro_end: loc.begin: 1565 3, loc.end: 1566 3
macro_begin: name: "matx", params: {j, k}, loc.begin: 1566 3, loc.end: 1568 3, text: "matx(j,k)"
macro_end: loc.begin: 1566 3, loc.end: 1568 3
macro_begin: name: "matx_arc", params: {j, k}, loc.begin: 1568 3, loc.end: 1570 3, text: "matx_arc(j,k)"
macro_end: loc.begin: 1568 3, loc.end: 1570 3
macro_begin: name: "INF", params: {}, loc.begin: 1570 3, loc.end: 1572 3, text: "INF "
macro_end: loc.begin: 1570 3, loc.end: 1572 3
middle_end: loc.begin: 1570 3, loc.end: 1572 3
c_begin: loc.begin: 1570 3, loc.end: 1572 3
named_section_begin: name: "Do stage 2 of |cher_tar_kar|", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 1572 3, loc.end: 1573 19, text: "
gv=g->vertices; "
comment_begin: type: "c", loc.begin: 1572 3, loc.end: 1573 19
free_text: type: "tex", loc.begin: 1573 19, loc.end: 1573 41, text: " the global variable "
inner_c_begin: loc.begin: 1573 19, loc.end: 1573 41
free_text: type: "c", loc.begin: 1573 41, loc.end: 1573 44, text: "gv"
inner_c_end: loc.begin: 1573 41, loc.end: 1573 44
free_text: type: "tex", loc.begin: 1573 44, loc.end: 1573 77, text: " helps access auxiliary memory "
comment_end: type: "c", loc.begin: 1573 44, loc.end: 1573 77
section_name: name: "Map all vertices to their index numbers", isPrefix: loc.begin: 1573 77, loc.end: 1574 3, false
section_name: name: "Create the reduced matrix by running through all remaining edges", isPrefix: loc.begin: 1574 3, loc.end: 1575 3, false
section_name: name: "Execute Prim's algorithm on the reduced matrix", isPrefix: loc.begin: 1575 3, loc.end: 1576 3, false
free_text: type: "c", loc.begin: 1576 3, loc.end: 1578 3, text: ";

@ "
named_section_end: loc.begin: 1576 3, loc.end: 1578 3
c_end: loc.begin: 1576 3, loc.end: 1578 3
tex_begin: loc.begin: 1576 3, loc.end: 1578 3
tex_section_begin: type: "unstarred", loc.begin: 1576 3, loc.end: 1578 3
free_text: type: "tex", loc.begin: 1578 3, loc.end: 1578 65, text: "The vertex-mapping algorithm is $O(n)$ because each non-null "
inner_c_begin: loc.begin: 1578 3, loc.end: 1578 65
free_text: type: "c", loc.begin: 1578 65, loc.end: 1578 70, text: "comp"
inner_c_end: loc.begin: 1578 65, loc.end: 1578 70
free_text: type: "tex", loc.begin: 1578 70, loc.end: 1579 46, text: " link
is examined at most three times. We set the "
inner_c_begin: loc.begin: 1578 70, loc.end: 1579 46
free_text: type: "c", loc.begin: 1579 46, loc.end: 1579 51, text: "comp"
inner_c_end: loc.begin: 1579 46, loc.end: 1579 51
free_text: type: "tex", loc.begin: 1579 51, loc.end: 1580 24, text: " field to null
as an indication that "
inner_c_begin: loc.begin: 1579 51, loc.end: 1580 24
free_text: type: "c", loc.begin: 1580 24, loc.end: 1580 31, text: "findex"
inner_c_end: loc.begin: 1580 24, loc.end: 1580 31
tex_section_end: loc.begin: 1580 31, loc.end: 1582 3
tex_end: loc.begin: 1580 31, loc.end: 1582 3
c_begin: loc.begin: 1580 31, loc.end: 1582 3
named_section_begin: name: "Map all...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1582 3, loc.end: 1596 3, text: "
if (s==NULL) s=large_list;
else o,t->rsib=large_list;
for (k=0,v=s;v;o,v=v->rsib,k++) o,v->findex=k;
for (v=g->vertices;v<g->vertices+g->n;v++)
  if (o,v->comp) {
    for (t=v->comp;o,t->comp;t=t->comp) ;
    o,k=t->findex;
    for (t=v;o,u=t->comp;t=u) {
      o,t->comp=NULL;
      o,t->findex=k;
    }
  }

@ "
named_section_end: loc.begin: 1582 3, loc.end: 1596 3
c_end: loc.begin: 1582 3, loc.end: 1596 3
tex_begin: loc.begin: 1582 3, loc.end: 1596 3
tex_section_begin: type: "unstarred", loc.begin: 1582 3, loc.end: 1596 3
tex_section_end: loc.begin: 1596 3, loc.end: 1596 5
tex_end: loc.begin: 1596 3, loc.end: 1596 5
c_begin: loc.begin: 1596 3, loc.end: 1596 5
named_section_begin: name: "Create the reduced matrix by running through all remaining edges", isPrefix: false, isContinuation: "false"
free_text: type: "c", loc.begin: 1596 5, loc.end: 1600 3, text: "
for (j=0;j<lo_sqrt;j++) for (k=0;k<lo_sqrt;k++) o,matx(j,k)=INF;
for (kk=0;s;o,s=s->rsib,kk++) qtraverse(s->pq,note_edge);

@ "
named_section_end: loc.begin: 1596 5, loc.end: 1600 3
c_end: loc.begin: 1596 5, loc.end: 1600 3
tex_begin: loc.begin: 1596 5, loc.end: 1600 3
tex_section_begin: type: "unstarred", loc.begin: 1596 5, loc.end: 1600 3
free_text: type: "tex", loc.begin: 1600 3, loc.end: 1600 8, text: "The "
inner_c_begin: loc.begin: 1600 3, loc.end: 1600 8
free_text: type: "c", loc.begin: 1600 8, loc.end: 1600 18, text: "note_edge"
inner_c_end: loc.begin: 1600 8, loc.end: 1600 18
free_text: type: "tex", loc.begin: 1600 18, loc.end: 1601 31, text: " procedure ``visits'' every edge in the
binomial queues traversed by "
inner_c_begin: loc.begin: 1600 18, loc.end: 1601 31
free_text: type: "c", loc.begin: 1601 31, loc.end: 1601 41, text: "qtraverse"
inner_c_end: loc.begin: 1601 31, loc.end: 1601 41
free_text: type: "tex", loc.begin: 1601 41, loc.end: 1602 18, text: " in the preceding code.
Global variable "
inner_c_begin: loc.begin: 1601 41, loc.end: 1602 18
free_text: type: "c", loc.begin: 1602 18, loc.end: 1602 21, text: "kk"
inner_c_end: loc.begin: 1602 18, loc.end: 1602 21
tex_section_end: loc.begin: 1602 21, loc.end: 1606 3
tex_end: loc.begin: 1602 21, loc.end: 1606 3
c_begin: loc.begin: 1602 21, loc.end: 1606 3
named_section_begin: name: "Procedures to be declared early", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1609 4, loc.end: 1619 3, text: "register long k;
  oo,k=a->tip->findex;
  if (k==kk) return;
  if (oo,a->len<matx(kk,k)) {
    o,matx(kk,k)=a->len;
    o,matx(k,kk)=a->len;
    matx_arc(kk,k)=matx_arc(k,kk)=a;
  }
}

@ "
named_section_end: loc.begin: 1609 4, loc.end: 1619 3
c_end: loc.begin: 1609 4, loc.end: 1619 3
tex_begin: loc.begin: 1609 4, loc.end: 1619 3
tex_section_begin: type: "unstarred", loc.begin: 1609 4, loc.end: 1619 3
free_text: type: "tex", loc.begin: 1619 3, loc.end: 1621 60, text: "As we work on the final subproblem of size $\lsqrtn\times\lsqrtn$,
we'll have a short vector that tells us the distance to each fragment that
hasn't yet been joined up with fragment~0. The vector has "
inner_c_begin: loc.begin: 1619 3, loc.end: 1621 60
free_text: type: "c", loc.begin: 1621 60, loc.end: 1621 63, text: "-1"
inner_c_end: loc.begin: 1621 60, loc.end: 1621 63
free_text: type: "tex", loc.begin: 1621 63, loc.end: 1623 24, text: " in positions
that already have been joined up. In a production version, we could
keep this in row~0 of "
inner_c_begin: loc.begin: 1621 63, loc.end: 1623 24
free_text: type: "c", loc.begin: 1623 24, loc.end: 1623 29, text: "matx"
inner_c_end: loc.begin: 1623 24, loc.end: 1623 29
tex_section_end: loc.begin: 1623 29, loc.end: 1625 3
tex_end: loc.begin: 1623 29, loc.end: 1625 3
c_begin: loc.begin: 1623 29, loc.end: 1625 3
named_section_begin: name: "Glob...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1625 3, loc.end: 1626 12, text: "
long kk; "
comment_begin: type: "c", loc.begin: 1625 3, loc.end: 1626 12
free_text: type: "tex", loc.begin: 1626 12, loc.end: 1626 32, text: " current fragment "
comment_end: type: "c", loc.begin: 1626 12, loc.end: 1626 32
free_text: type: "c", loc.begin: 1626 32, loc.end: 1627 23, text: "
long distance[100]; "
comment_begin: type: "c", loc.begin: 1626 32, loc.end: 1627 23
free_text: type: "tex", loc.begin: 1627 23, loc.end: 1627 72, text: " distances to at most \lsqrtn\ unhit fragments "
comment_end: type: "c", loc.begin: 1627 23, loc.end: 1627 72
free_text: type: "c", loc.begin: 1627 72, loc.end: 1628 23, text: "
Arc *dist_arc[100]; "
comment_begin: type: "c", loc.begin: 1627 72, loc.end: 1628 23
free_text: type: "tex", loc.begin: 1628 23, loc.end: 1628 53, text: " the corresponding arcs, for "
inner_c_begin: loc.begin: 1628 23, loc.end: 1628 53
free_text: type: "c", loc.begin: 1628 53, loc.end: 1628 61, text: "verbose"
inner_c_end: loc.begin: 1628 53, loc.end: 1628 61
free_text: type: "tex", loc.begin: 1628 61, loc.end: 1628 69, text: " mode "
comment_end: type: "c", loc.begin: 1628 61, loc.end: 1628 69
free_text: type: "c", loc.begin: 1628 69, loc.end: 1630 3, text: "

@ "
named_section_end: loc.begin: 1628 69, loc.end: 1630 3
c_end: loc.begin: 1628 69, loc.end: 1630 3
tex_begin: loc.begin: 1628 69, loc.end: 1630 3
tex_section_begin: type: "unstarred", loc.begin: 1628 69, loc.end: 1630 3
index_entry: entry: "Prim, Robert Clay", loc.begin: 1630 3, loc.end: 1631 22
tex_section_end: loc.begin: 1631 22, loc.end: 1636 3
tex_end: loc.begin: 1631 22, loc.end: 1636 3
c_begin: loc.begin: 1631 22, loc.end: 1636 3
named_section_begin: name: "Execute Prim's algorithm on the reduced matrix", isPrefix: false, isContinuation: "false"
c_format: code: "@+"
free_text: type: "c", loc.begin: 1637 4, loc.end: 1637 14, text: "long d; "
comment_begin: type: "c", loc.begin: 1637 4, loc.end: 1637 14
free_text: type: "tex", loc.begin: 1637 14, loc.end: 1637 46, text: " shortest entry seen so far in "
inner_c_begin: loc.begin: 1637 14, loc.end: 1637 46
free_text: type: "c", loc.begin: 1637 46, loc.end: 1637 55, text: "distance"
inner_c_end: loc.begin: 1637 46, loc.end: 1637 55
free_text: type: "tex", loc.begin: 1637 55, loc.end: 1637 65, text: " vector "
comment_end: type: "c", loc.begin: 1637 55, loc.end: 1637 65
section_name: name: "Connect fragment 0 with fragment |j|, since |j| is the column
      achieving the smallest distance, |d|; also compute |j| and |d|
      for the next round", isPrefix: loc.begin: 1637 65, loc.end: 1646 7, false
free_text: type: "c", loc.begin: 1646 7, loc.end: 1649 3, text: ";
}

@ "
named_section_end: loc.begin: 1646 7, loc.end: 1649 3
c_end: loc.begin: 1646 7, loc.end: 1649 3
tex_begin: loc.begin: 1646 7, loc.end: 1649 3
tex_section_begin: type: "unstarred", loc.begin: 1646 7, loc.end: 1649 3
tex_section_end: loc.begin: 1649 3, loc.end: 1649 5
tex_end: loc.begin: 1649 3, loc.end: 1649 5
c_begin: loc.begin: 1649 3, loc.end: 1649 5
named_section_begin: name: "Connect fragment 0...", isPrefix: true, isContinuation: "false"
free_text: type: "c", loc.begin: 1649 5, loc.end: 1651 34, text: "
{
  if (d==INF) return INFINITY; "
comment_begin: type: "c", loc.begin: 1649 5, loc.end: 1651 34
free_text: type: "tex", loc.begin: 1651 34, loc.end: 1651 63, text: " the graph isn't connected "
comment_end: type: "c", loc.begin: 1651 34, loc.end: 1651 63
free_text: type: "c", loc.begin: 1651 63, loc.end: 1652 23, text: "
  o,distance[j]=-1; "
comment_begin: type: "c", loc.begin: 1651 63, loc.end: 1652 23
free_text: type: "tex", loc.begin: 1652 23, loc.end: 1652 34, text: " fragment "
inner_c_begin: loc.begin: 1652 23, loc.end: 1652 34
free_text: type: "c", loc.begin: 1652 34, loc.end: 1652 36, text: "j"
inner_c_end: loc.begin: 1652 34, loc.end: 1652 36
free_text: type: "tex", loc.begin: 1652 36, loc.end: 1652 72, text: " now will join up with fragment 0 "
comment_end: type: "c", loc.begin: 1652 36, loc.end: 1652 72
section_name: name: "Report the new edge verbosely", isPrefix: loc.begin: 1652 72, loc.end: 1656 7, false
free_text: type: "c", loc.begin: 1656 7, loc.end: 1671 16, text: ";
  }
  frags--;
  d=INF;
  for (k=1;k<lo_sqrt;k++)
    if (o,distance[k]>=0) {
      if (o,matx(j,k)<distance[k]) {
        o,distance[k]=matx(j,k);
        dist_arc[k]=matx_arc(j,k);
      }
      if (distance[k]<d) d=distance[k],kk=k;
    }
  j=kk;
}

@*"
named_section_end: loc.begin: 1656 7, loc.end: 1671 16
c_end: loc.begin: 1656 7, loc.end: 1671 16
tex_begin: loc.begin: 1656 7, loc.end: 1671 16
tex_section_begin: type: "starred", title: " Conclusions.", loc.begin: 1656 7, loc.end: 1671 16
free_text: type: "tex", loc.begin: 1671 16, loc.end: 1675 32, text: " The winning algorithm, of the four methods considered here,
on problems of the size considered here, with respect to mem counting, is
clearly Jarn{\'\i}k/Prim with binary heaps. Second is Kruskal with
radix sorting, on sparse graphs, but the Fibonacci heap method beats
it on dense graphs. Procedure "
inner_c_begin: loc.begin: 1671 16, loc.end: 1675 32
free_text: type: "c", loc.begin: 1675 32, loc.end: 1675 45, text: "cher_tar_kar"
inner_c_end: loc.begin: 1675 32, loc.end: 1675 45
index_entry: entry: "discussion of \\{mems}", loc.begin: 1675 45, loc.end: 1685 27
free_text: type: "tex", loc.begin: 1685 27, loc.end: 1700 2, text: "
running times when all the complications of pipelining, caching, and compiler
optimization are taken into account. These runs showed that Kruskal's
algorithm was actually best, at least on the particular system tested:
$$\advance\abovedisplayskip-5pt
\advance\belowdisplayskip-5pt
\advance\baselineskip-1pt
\vbox{\halign{#\hfil&&\quad\hfil#\cr
\hfill optimization level&\.{-g}\hfil&\.{-O2}\hfil&\.{-O3}\hfil&mems\hfil\cr
\noalign{\vskip2pt}
Kruskal/radix&132&111&111&8379\cr
Jarn{\'\i}k/Prim/binary&307&226&212&7972\cr
Jarn{\'\i}k/Prim/Fibonacci&432&350&333&11736\cr
Cheriton/Tarjan/Karp&686&509&492&17770\cr}}$$
(Times are shown in seconds per 100,000 runs with the default graph
"
inner_c_begin: loc.begin: 1685 27, loc.end: 1700 2
free_text: type: "c", loc.begin: 1700 2, loc.end: 1700 26, text: "miles(100,0,0,0,0,10,0)"
inner_c_end: loc.begin: 1700 2, loc.end: 1700 26
free_text: type: "tex", loc.begin: 1700 26, loc.end: 1706 58, text: ". Optimization level \.{-O4} gave the same results
as \.{-O3}. Optimization does not change the mem count.) Thus the Kruskal
procedure used only about 160 nanoseconds per mem, without optimization,
and about 130 with; the others used about 380 to 400 ns/mem without
optimization, 270 to 300 with. The mem measure gave consistent readings for
the three ``sophisticated'' data structures, but the ``na{\"\i}ve'' Kruskal
method blended better with hardware. The complete graph "
inner_c_begin: loc.begin: 1700 26, loc.end: 1706 58
free_text: type: "c", loc.begin: 1706 58, loc.end: 1707 7, text: "miles(100,0,0,0,0,
99,0)"
inner_c_end: loc.begin: 1706 58, loc.end: 1707 7
free_text: type: "tex", loc.begin: 1707 7, loc.end: 1728 6, text: ", obtained by specifying option \.{-d100}, gave somewhat different
statistics:
$$\advance\abovedisplayskip-5pt
\advance\belowdisplayskip-5pt
\advance\baselineskip-1pt
\vbox{\halign{#\hfil&&\quad\hfil#\cr
\hfill optimization level&\.{-g}\hfil&\.{-O2}\hfil&\.{-O3}\hfil&mems\hfil\cr
\noalign{\vskip2pt}
Kruskal/radix&1846&1787&1810&63795\cr
Jarn{\'\i}k/Prim/binary&2246&1958&1845&50594\cr
Jarn{\'\i}k/Prim/Fibonacci&2675&2377&2248&59050\cr
Cheriton/Tarjan/Karp&8881&6964&6909&175519\cr}}$$
% Kruskal 285 ns/mem; others 360--450, except unoptimized CTK was 536!
Now the identical machine instructions took significantly longer per
mem---presumably because of cache misses, although the frequency of
conditional jump instructions might also be a factor.  Careful analyses
of these phenomena should be instructive.  Future computers are
expected to be more nearly limited by memory speed; therefore the running
time per mem is likely to become more uniform between methods, although
cache performance will probably always be a factor.

The "
inner_c_begin: loc.begin: 1707 7, loc.end: 1728 6
free_text: type: "c", loc.begin: 1728 6, loc.end: 1728 12, text: "krusk"
inner_c_end: loc.begin: 1728 6, loc.end: 1728 12
free_text: type: "tex", loc.begin: 1728 12, loc.end: 1732 10, text: " procedure might go even faster if it were
given a streamlined union/find algorithm. Or would such ``streamlining''
negate some of its present efficiency?

@*"
tex_section_end: loc.begin: 1728 12, loc.end: 1732 10
tex_end: loc.begin: 1728 12, loc.end: 1732 10
tex_begin: loc.begin: 1728 12, loc.end: 1732 10
tex_section_begin: type: "starred", title: " Index.", loc.begin: 1728 12, loc.end: 1732 10
free_text: type: "tex", loc.begin: 1732 10, loc.end: 1736 1, text: " We close with a list that shows where the identifiers of this
program are defined and used. A special index term, `discussion of \\{mems}',
indicates sections where there are nontrivial comments about instrumenting
a \CEE/ program in the manner being recommended here.
"
tex_section_end: loc.begin: 1732 10, loc.end: 1736 1
tex_end: loc.begin: 1732 10, loc.end: 1736 1
file_end: file: "miles_span.w"
document_end:
